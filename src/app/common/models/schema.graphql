# Controls the rate of traffic.
directive @rateLimit(
  # Number of occurrences allowed over duration.
  limit: Int! = 60

  # Number of seconds before limit is reset.
  duration: Int! = 60
) on OBJECT | FIELD_DEFINITION

directive @cacheControl(
  maxAge: Int
  scope: CacheControlScope
) on OBJECT | FIELD_DEFINITION

type AchievementReward {
  amount: Float!
  ancestorBoxId: ID
  box: Box
  currency: String
  itemVariantId: ID
  itemVariant: ItemVariant
  onlyForMarketId: ID
  onlyForMarket: Market
  type: AchievementRewardType!
  walletType: WalletType
}

input AchievementRewardInput {
  amount: Float!
  ancestorBoxId: ID
  currency: String
  itemVariantId: ID
  onlyForMarketId: ID
  type: AchievementRewardType!
  walletType: WalletType
}

enum AchievementRewardType {
  BOX
  ITEM_VARIANT
  JACKPOT_TICKET
  WALLET
  XP
}

type AchievementTrigger {
  channels: [String]
  contains: String
  currency: String
  gameTypes: [GameType!]
  minAmount: Float
  type: AchievementTriggerType!
  userItemUsed: Boolean
}

input AchievementTriggerInput {
  channels: [String]
  contains: String
  currency: String
  gameTypes: [GameType!]
  minAmount: Float
  type: AchievementTriggerType!
  userItemUsed: Boolean
}

enum AchievementTriggerType {
  CHAT_MESSAGE
  LOST_WAGER_ON_GAME
  TWITTER_FOLLOWER
  WAGER_ON_GAME
}

type BonusAmount {
  amount: Float
  currency: String
  market: Market
  marketId: ID
}

type Achievement implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  name: String!
  description: String!
  imageUrl: String!
  bonusAmounts: [BonusAmount!]
  rewards: [AchievementReward!]!
  xpAmount: Int
  bonusExpirySeconds: Int
  rewardsExpireAfterSeconds: Int!
  enabled: Boolean!
  users: [User]
  type: AchievementType
  autoClaim: Boolean!
  limitPerUser: Int
  trigger: AchievementTrigger
  userAchievements(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    userId: ID
  ): UserAchievementConnection!
}

type AchievementConnection {
  pageInfo: PageInfo!
  edges: [AchievementEdge]
  total: Int
}

type AchievementEdge {
  node: Achievement
  cursor: String!
}

type CreateAchievementPayload {
  achievement: Achievement
}

type UpdateAchievementPayload {
  achievement: Achievement
}

type DeleteAchievementPayload {
  achievement: Achievement
}

type FlushAchievementCachePayload {
  achievements: [Achievement]
}

type Query {
  achievement(id: ID!): Achievement
  achievements(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [AchievementOrderBy]
    achievementIds: [ID!]
    enabled: Boolean
    name: String
    types: [AchievementType!]
  ): AchievementConnection!
  getAffiliateImageUrls(input: AffiliateUserIdentifier): AffiliateUrlsPayload
  getAffiliateImageUrl(
    input: AffiliatePromoImageIdentifier
  ): AffiliateUrlPayload
  getAffiliateBlogPosts(input: AffiliateBlogInput): AffiliateBlogPostsPayload
  affiliateLoanRequest(id: ID!): AffiliateLoanRequest
  affiliateLoanRequests(
    input: AffiliateLoanRequestArgs
  ): AffiliateLoanRequestConnection!
  affiliateActiveCountInDateRange(
    input: AffiliateActiveCountInput
  ): AffiliateActiveCountResult
  affiliateAllTime(input: AffiliateAllTimeInput): AffiliateAllTimeResult
  affiliateDailyEarnings(
    input: AffiliateEarningsInput
  ): [AffiliateEarningsResult]
  affiliateMonthlyEarnings(
    input: AffiliateEarningsInput
  ): [AffiliateEarningsResult]
  affiliateStatusCounts(
    input: AffiliateStatusCountsInput
  ): AffiliateStatusCountResult
  affiliateTotalEarnings(
    input: AffiliateEarningsInput
  ): [AffiliateEarningsResult]
  refereeActivity(input: RefereeActivityInput!): RefereeActivityResult
  refereeDailyOrHourlyActivity(
    input: RefereeDailyActivityInput
  ): RefereeDailyActivityResult
  totalCommisionGivenAway: TotalCommisionGivenAwayPayload!
  getRefereeStatus(input: RefereeStatusInput): RefereeStatusResult!
  affiliateSearch(input: AffiliateSearchInputs): AffiliateSearchConnection!
  affiliateTier(id: ID!): AffiliateTier
  affiliateTiers(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [AffiliateTierOrderBy]
    ancestorAffiliateTierId: ID
  ): AffiliateTierConnection!
  asset(id: ID): Asset
  assets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [AssetOrderBy]
    fileName: String
  ): AssetConnection!
  bet(id: ID!): Bet
  bets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [BetOrderBy]
    gameId: ID
    userId: ID
    selection: Int
    selections: [Int!]
  ): BetConnection!
  cachedGameBets(gameId: ID!): [Bet!]!
  boxOpening(id: ID): BoxOpening
  boxOpenings(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [BoxOpeningOrderBy]
    boxId: ID
    userId: ID
    ancestorBoxId: ID
    minItemValue: Float
    maxItemValue: Float
    minDate: SequelizeDate
    maxDate: SequelizeDate
    name: String
    hasPvpGame: Boolean
    pvpGameId: ID
  ): BoxOpeningConnection!
  boxOpeningsByValue(
    limit: PaginationAmount
    ancestorBoxId: ID
    boxSlug: String
  ): [BoxOpening]
  boxOpeningsByTime(
    limit: PaginationAmount
    ancestorBoxId: ID
    boxSlug: String
  ): [BoxOpening]
  boxStats(
    excludeAuthenticated: Boolean
    combineAncestors: Boolean
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): [BoxStat]
  boxItemVariantStats(
    boxId: ID!
    combineAncestors: Boolean
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): [BoxItemVariantStat]
  luckiestBoxOpening(marketId: ID, userId: ID): LuckiestBoxOpening!
  box(id: ID, marketId: ID, marketSlug: String, slug: String): Box
  boxes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [BoxOrderBy]
    itemId: ID
    tags: [String]
    excludeTags: [String]
    name: String
    minLevelRequired: Int
    free: Boolean
    availableFrom: SequelizeDate
    availableUntil: SequelizeDate
    minValue: Float
    maxValue: Float
    type: BoxType
    walletRestrictions: [WalletType]
    enabled: Boolean
    purchasable: Boolean
    openable: Boolean
    sellable: Boolean
    ancestorBoxId: ID
    marketId: ID
    marketSlug: String
    itemIds: [ID!]
    minCost: Float
    maxCost: Float
    discounted: Boolean
    dailyLimited: Boolean
  ): BoxConnection!
  favouriteBox(marketId: ID, userId: ID): FavouriteBox!
  calendarEntry(id: ID): CalendarEntry
  calendarEntries(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CalendarEntryOrderBy]
    calendarId: ID
    userId: ID
  ): CalendarEntryConnection!
  calendar(id: ID): Calendar
  calendars(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CalendarOrderBy]
  ): CalendarConnection!
  countries: [Country]
  countryDetected: Country
  crashBetItem(id: ID!): CrashBetItem
  crashBetItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CrashBetItemOrderBy]
  ): CrashBetItemConnection!
  crashBet(id: ID!): CrashBet
  crashBets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CrashBetOrderBy]
    gameId: ID
    userId: ID
  ): CrashBetConnection!
  crashBetItemVariants(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    marketId: ID!
    minValue: Float!
  ): CrashBetItemVariantConnection!
  crashBetStats(userId: ID!, limit: Int): CrashBetStats!
  crashGame(id: ID!): CrashGame
  crashGames(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CrashGameOrderBy]
    status: CrashGameStatus
  ): CrashGameConnection!
  cronJob(id: ID!): CronJob
  cronJobs(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [CronJobOrderBy]
  ): CronJobConnection!
  dashboard: Dashboard
  getCacheValue(key: String!): String
  getParsedCacheValue(key: String!): JSON
  diceBet(id: ID!): DiceBet
  diceBets(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [DiceBetOrderBy]
    maxAmount: Float
    maxTotalPayout: Float
    maxProfit: Float
    minAmount: Float
    minTotalPayout: Float
    minProfit: Float
    userId: ID
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    gameTypes: [DiceGameType!]
  ): DiceBetConnection!
  diceBetJackpotEntries(
    minAmount: Float!
    minTotalPayout: Float!
    createdAtMinDate: SequelizeDate!
    createdAtMaxDate: SequelizeDate!
    first: PaginationAmount!
    gameType: DiceGameType!
  ): [DiceBet!]!
  digitalCode(id: ID!): DigitalCode
  digitalCodes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [DigitalCodeOrderBy]
    availableOnly: Boolean
    code: String
    itemVariantId: ID
    userId: ID
  ): DigitalCodeConnection!
  document(id: ID): Document
  documents(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [DocumentOrderBy]
    userId: ID
  ): DocumentConnection!
  ebaySearch(
    searchString: String!
    country: String!
    minQ: Int!
    limit: Int!
    page: Int!
    priceSort: String!
    minPrice: Float!
  ): EbaySearch
  waitingListEmail(id: ID): EmailWaitingList
  waitingListEmails(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [EmailWaitingListOrderBy]
    emails: [String]
    statuses: [EmailWaitingListStatus!]
  ): EmailWaitingListConnection!
  getEosBlock(blockNumberOrId: String!): JSON
  getEosChainInfo: JSON
  getEosCurrentSimpleBlock: JSON
  getEosSimpleBlock(blockNumber: Int!): JSON
  exchangeRate(source: String, target: String): ExchangeRate
  exchangeRates(source: String, targets: [String!]): ExchangeRates
  exchange(id: ID!): Exchange
  exchanges(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ExchangeOrderBy]
    userId: ID
  ): ExchangeConnection!
  gameJackpotWinner(id: ID!): GameJackpotWinner
  gameJackpotWinners(
    gameId: String
    gameJackpotId: String
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [GameJackpotWinnerOrderBy]
  ): GameJackpotWinnerConnection!
  gameJackpot(id: ID!): GameJackpot
  gameJackpots(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [GameJackpotOrderBy]
  ): GameJackpotConnection!
  cachedLatestGames(gameId: ID, last: Int!): [Game!]!
  game(id: ID!): Game
  games(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [GameOrderBy]
    status: GameStatus
    minRollId: ID
    maxRollId: ID
  ): GameConnection!
  gemstoneBoostActivation(id: ID!): GemstoneBoostActivation
  gemstoneBoostActivations(
    active: Boolean
    after: String
    before: String
    first: PaginationAmount
    gemstoneBoostId: ID
    last: PaginationAmount
    orderBy: [GemstoneBoostActivationOrderBy]
    teamIds: [ID!]
  ): GemstoneBoostActivationConnection!
  gemstoneBoostInfo(
    gemstoneBoostId: ID
    teamIds: [ID!]!
    walletType: WalletType!
  ): GemstoneBoostInfo!
  gemstoneGame(id: ID): GemstoneGame
  gemstoneGames(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [GemstoneGameOrderBy]
    createdAtMaxDate: SequelizeDate
    createdAtMinDate: SequelizeDate
    externalId: ID
    externalModel: String
    maxAmount: Float
    maxBet: Float
    minAmount: Float
    minBet: Float
    userId: ID
    walletType: WalletType
  ): GemstoneGameConnection!
  gemstoneGameLeaderboard(
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    limit: Int!
    teamId: ID
    walletType: WalletType!
  ): GemstoneGameLeaderboard!
  geoTrack(id: ID!): GeoTrack
  geoTracks(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [GeoTrackOrderBy]
    countries: [String!]
    createdAtMaxDate: SequelizeDate
    createdAtMinDate: SequelizeDate
    ips: [String!]
    userIds: [ID!]
  ): GeoTrackConnection!
  geoTrackSummary(date: SequelizeDate): GeoTrackSummary
  geoTrackUserSummary(date: SequelizeDate, userId: ID!): GeoTrackUserSummary
  giveaway(id: ID!): Giveaway
  giveaways(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [GiveawayOrderBy]
    statuses: [GiveawayStatus!]
  ): GiveawayConnection!
  inviteCode(id: ID!): InviteCode
  inviteCodes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [InviteCodeOrderBy]
    code: String
    userId: ID
  ): InviteCodeConnection!
  itemCategory(id: ID!): ItemCategory
  itemCategories(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ItemCategoryOrderBy]
    name: String
  ): ItemCategoryConnection!
  inventoryItemVariants(
    allowCached: Boolean
    steamAppName: SteamAppName
    steamId: String
    userId: ID
  ): Inventory!
  itemVariant(id: ID!): ItemVariant
  itemVariants(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ItemVariantOrderBy]
    name: String
    minValue: Float
    maxValue: Float
    obtainable: Boolean
    usable: Boolean
    withdrawable: Boolean
    type: ItemType
    depositable: Boolean
    categoryId: ID
    itemId: ID
    marketId: ID
    purchasable: ItemPurchasable
    canBuy: Boolean
    minAvailableAt: SequelizeDate
    maxAvailableAt: SequelizeDate
    distinctDisplayValues: Boolean
    distinctValues: Boolean
    retailers: [Retailer!]
    minTotalRequested: Int
    minTotalUnfulfilled: Int
    minValueUpdatedAt: SequelizeDate
    maxValueUpdatedAt: SequelizeDate
  ): ItemVariantConnection!
  item(id: ID!): Item
  items(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ItemOrderBy]
    name: String
    minValue: Float
    maxValue: Float
    obtainable: Boolean
    usable: Boolean
    withdrawable: Boolean
    type: ItemType
    categoryId: ID
    marketId: ID
    distinctDisplayValues: Boolean
    distinctValues: Boolean
    minValueUpdatedAt: SequelizeDate
    maxValueUpdatedAt: SequelizeDate
    boxIds: [ID!]
    containedInAnyBox: Boolean
    tagIds: [ItemTagInput!]
    retailers: [Retailer!]
  ): ItemConnection!
  jackpotWinningTicket(id: ID!): JackpotWinningTicket
  jackpotWinningTickets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [JackpotWinningTicketOrderBy]
    jackpotId: ID
  ): JackpotWinningTicketConnection
  jackpot(id: ID!): Jackpot
  jackpots(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [JackpotOrderBy]
    won: Boolean
  ): JackpotConnection!
  jackpotLeaderboard(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    jackpotId: ID
  ): JackpotLeaderboardConnection!
  location: Location
  detectedMarket: Market
  market(id: ID!): Market
  markets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MarketOrderBy]
    slug: String
  ): MarketConnection!
  matchBettingGame(id: ID!): MatchBettingGame
  matchBettingGames(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    order: [MatchBettingGameOrderBy]
    externalIds: [String!]
    gameIds: [ID!]
    matchIds: [ID!]
    providers: [MatchBettingProvider!]
    statuses: [MatchBettingGameStatus!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingGameConnection!
  matchBettingLeague(id: ID!): MatchBettingLeague
  matchBettingLeagues(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingLeagueOrderBy]
    externalIds: [String!]
    externalSlugs: [String!]
    leagueIds: [ID!]
    name: String
    providers: [MatchBettingProvider!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingLeagueConnection!
  matchBettingMarket(id: ID!): MatchBettingMarket
  matchBettingMarkets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingMarketOrderBy]
    externalIds: [String!]
    gameIds: [ID!]
    marketIds: [ID!]
    matchIds: [ID!]
    name: String
    providers: [MatchBettingProvider!]
    statuses: [MatchBettingMarketStatus!]
    types: [MatchBettingMarketType!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingMarketConnection!
  matchBettingMatch(id: ID!): MatchBettingMatch
  matchBettingMatches(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingMatchOrderBy]
    externalIds: [String!]
    externalSlugs: [String!]
    leagueIds: [ID!]
    matchIds: [ID!]
    name: String
    providers: [MatchBettingProvider!]
    serieIds: [ID!]
    statuses: [MatchBettingMatchStatus!]
    tournamentIds: [ID!]
    types: [MatchBettingMatchType!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingMatchConnection!
  matchBettingPlayer(id: ID!): MatchBettingPlayer
  matchBettingPlayers(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingPlayerOrderBy]
    currentTeamIds: [ID!]
    externalIds: [String!]
    externalSlugs: [String!]
    name: String
    playerIds: [ID!]
    providers: [MatchBettingProvider!]
  ): MatchBettingPlayerConnection!
  matchBettingSerie(id: ID!): MatchBettingSerie
  matchBettingSeries(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingSerieOrderBy]
    externalIds: [String!]
    externalSlugs: [String!]
    fullName: String
    leagueIds: [ID!]
    providers: [MatchBettingProvider!]
    serieIds: [ID!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingSerieConnection!
  matchBettingSlip(id: ID!): MatchBettingSlip
  matchBettingSlips(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingSlipOrderBy]
    createdAtMaxDate: SequelizeDate
    createdAtMinDate: SequelizeDate
    providers: [MatchBettingProvider!]
    slipIds: [ID!]
    statuses: [MatchBettingSlipStatus!]
    types: [MatchBettingSlipType!]
    userIds: [ID!]
  ): MatchBettingSlipConnection!
  matchBettingTeam(id: ID!): MatchBettingTeam
  matchBettingTeams(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingTeamOrderBy]
    externalIds: [String!]
    externalSlugs: [String!]
    name: String
    providers: [MatchBettingProvider!]
    teamIds: [ID!]
  ): MatchBettingTeamConnection!
  matchBettingTournament(id: ID!): MatchBettingTournament
  matchBettingTournaments(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MatchBettingTournamentOrderBy]
    externalIds: [String!]
    externalSlugs: [String!]
    leagueIds: [ID!]
    name: String
    providers: [MatchBettingProvider!]
    serieIds: [ID!]
    tournamentIds: [ID!]
    videoGames: [MatchBettingVideoGame!]
  ): MatchBettingTournamentConnection!
  message(id: ID!): Message
  messages(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [MessageOrderBy]
    channel: String
    channels: [String]
    showDeleted: Boolean
    userId: ID
  ): MessageConnection!
  cachedMessages(
    first: PaginationAmount
    channels: [String]
  ): MessageConnection!
  note(id: ID!): Note
  notes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [NoteOrderBy]
    userId: ID!
    creatorId: ID
  ): NoteConnection!
  notificationMessage(id: ID!): NotificationMessage
  notificationMessages(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [NotificationMessageOrderBy]
    notificationId: ID
    notificationOwnerId: ID
    unreadOnly: Boolean
  ): NotificationMessageConnection!
  notification(id: ID!): Notification
  notifications(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [NotificationOrderBy]
    externalId: Int
    externalModel: String
    type: NotificationType
    unreadOnly: Boolean
    userId: ID
    withMessages: Boolean
  ): NotificationConnection!
  orderNote(id: ID!): OrderNote
  orderNotes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [OrderNoteOrderBy]
    orderId: ID!
    creatorId: ID
  ): OrderNoteConnection!
  order(id: ID!): Order
  orders(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [OrderOrderBy]
    userId: ID
    creatorId: ID
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    retailer: Retailer
    itemName: String
  ): OrderConnection!
  retailerDeliveryStats(
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): RetailerDeliveryStatsResponse
  paymentOption(id: ID!): PaymentOption
  paymentOptions(
    countryCode: String
    visible: Boolean
    action: PaymentOptionAction
  ): [PaymentOption]
  promoCode(id: ID!): PromoCode
  promoCodes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [PromoCodeOrderBy]
    affiliateUserId: ID
    expired: Boolean
    code: String
    type: PromoCodeType
    createdAt: String
    marketId: ID
    walletType: WalletType
  ): PromoCodeConnection!
  promoCodeTimer(code: String!, amount: Float!): PromoCodeTimer!
  pvpBet(id: ID!): PvpBet
  pvpBets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [PvpBetOrderBy]
    bigWin: Boolean
    gameType: PvpGameType
    gameTypes: [PvpGameType!]
    pvpBetId: ID
    pvpGameId: ID
    pvpRoundId: ID
    statuses: [PvpBetStatus!]
    userId: ID
  ): PvpBetConnection!
  pvpBot(id: ID!): PvpBot
  pvpBots(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [PvpBotOrderBy]
    currencies: [String!]
    pvpBotIds: [ID!]
    statuses: [PvpBotStatus!]
    userIds: [ID!]
  ): PvpBotConnection!
  pvpGame(id: ID!): PvpGame
  pvpGames(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [PvpGameOrderBy]
    hasPvpBot: Boolean
    pvpGameId: ID
    statuses: [PvpGameStatus!]
    type: PvpGameType
    types: [PvpGameType!]
    userId: ID
  ): PvpGameConnection!
  pvpRound(id: ID!): PvpRound
  pvpRounds(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [PvpRoundOrderBy]
    gameType: PvpGameType
    gameTypes: [PvpGameType!]
    hasPvpBot: Boolean
    minBiggestWinValue: Float
    pvpGameId: ID
    pvpRoundId: ID
    statuses: [PvpRoundStatus!]
    userId: ID
  ): PvpRoundConnection!
  node(id: ID!): Node
  roll(id: ID!): Roll
  rolls(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [RollOrderBy]
    game: GameType
  ): RollConnection!
  rollHistory(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: RollOrderBy
    game: GameType
  ): [RollHistory]!
  commitVersion: CommitVersion
  onlineCount: Int
  time: SequelizeDate
  seed(id: ID!): Seed
  seeds(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [SeedOrderBy]
    userId: ID!
    type: SeedType
  ): SeedConnection!
  setting(key: String!): Setting
  settingsByKeys(keys: [String]!): [Setting]
  settings: [Setting]
  steamAsset(id: ID!): SteamAsset
  steamAssets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [SteamAssetOrderBy]
    itemVariantId: ID
    steamBotId: ID
    incomingSteamOfferId: ID
    outgoingSteamOfferId: ID
    minLockExpiresAt: SequelizeDate
    maxLockExpiresAt: SequelizeDate
  ): SteamAssetConnection!
  steamBot(id: ID!): SteamBot
  steamBots(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [SteamBotOrderBy]
    steamBotId: ID
    username: String
    steamId: String
    banned: Boolean
    steamGame: Int
    type: SteamBotType
  ): SteamBotConnection!
  steamOfferItemVariant(id: ID!): SteamOfferItemVariant
  steamOfferItemVariants(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [SteamOfferItemVariantOrderBy]
    steamOfferId: ID
  ): SteamOfferItemVariantConnection!
  steamOffer(id: ID!): SteamOffer
  steamOffers(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [SteamOfferOrderBy]
    steamOfferId: ID
    userId: ID
    steamBotId: ID
    tradeId: ID
    tradeOfferId: String
    state: SteamOfferState
  ): SteamOfferConnection!
  steam2FACode(sharedSecret: String!): String
  steamInventory(
    allowCached: Boolean!
    onlyResponse: Boolean!
    steamAppName: SteamAppName!
    userId: ID!
  ): JSON!
  steamUserTradeHistory(
    userId: ID!
    since: Int
    withSteamId: String
    onlyCompleted: Boolean
  ): SteamUserTradeHistory!
  tag(id: ID!): Tag
  tags(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [TagOrderBy]
    name: String
    visible: Boolean
  ): TagConnection!
  team(id: ID!): Team
  teams(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [TeamOrderBy]
  ): TeamConnection!
  ticket(id: ID!): Ticket
  tickets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [TicketOrderBy]
    jackpotId: ID
    userId: ID
  ): TicketConnection!
  tradeItem(id: ID!): TradeItem
  tradeItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [TradeItemOrderBy]
    tradeId: ID
  ): TradeItemConnection!
  trade(id: ID!): Trade
  trades(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [TradeOrderBy]
    tradeId: ID
    userId: ID
    depositorSteamId: String
    withdrawerSteamId: String
    steamAppName: SteamAppName
    status: TradeStatus
    minTotalValue: Float
    maxTotalValue: Float
    marketName: String
    statuses: [TradeStatus!]
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    maxMarkupPercent: Float
  ): TradeConnection!
  transaction(id: ID, externalId: ID): Transaction
  transactions(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [TransactionOrderBy]
    minDate: String
    maxDate: String
    promoCodeId: ID
    provider: PaymentProvider
    statuses: [TransactionStatus!]
    types: [TransactionType!]
    userId: ID
  ): TransactionConnection!
  userAchievement(id: ID!): UserAchievement
  userAchievements(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserAchievementOrderBy]
    achievementIds: [ID!]
    types: [AchievementType!]
    userAchievementIds: [ID!]
    userId: ID
    userIds: [ID!]
  ): UserAchievementConnection
  userBox(id: ID!): UserBox
  userBoxes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserBoxOrderBy]
    categoryId: ID
    userId: ID
    name: String
    status: [UserBoxStatus]
  ): UserBoxConnection!
  userCommunication(id: ID!): UserCommunication
  userCommunications(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserCommunicationOrderBy]
    mutedUserIds: [ID!]
    userId: ID
  ): UserCommunicationConnection!
  userGiveaway(id: ID): UserGiveaway
  userGiveaways(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [UserGiveawayOrderBy]
    giveawayId: ID
    userId: ID
  ): UserGiveawayConnection!
  userItem(id: ID!): UserItem
  userItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserItemOrderBy]
    categoryId: ID
    retailer: [Retailer!]
    userId: ID
    name: String
    status: [UserItemStatus]
    itemType: [ItemType!]
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    exchangedForBalance: Boolean
  ): UserItemConnection!
  userProgressChange(id: ID!): UserProgressChange
  userProgressChanges(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [UserProgressChangeOrderBy]
    sources: [UserProgressSource!]
    userId: ID
  ): UserProgressChangeConnection
  userProgressChangesSummary(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [UserProgressChangeSummaryOrderBy]
    maxDate: SequelizeDate
    minDate: SequelizeDate
    userId: ID
  ): UserProgressChangesSummaryConnection!
  userPromoCodes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserPromoCodeOrderBy]
    code: String
    promoCodeId: ID
    userId: ID
  ): UserPromoCodeConnection!
  userStat(id: ID!): UserStat
  userStats(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserStatOrderBy]
    userId: ID
    userStatId: ID
    marketId: ID
    excluded: Boolean
    includeOwnersAndBots: Boolean
    stat: [UserStatStat!]
    type: [UserStatType!]
    dateFrom: SequelizeDate
    dateTo: SequelizeDate
    excludeBannedUsers: Boolean
  ): UserStatConnection!
  currentUser: User
  sessionHash: String!
  user(id: ID!): User
  users(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserOrderBy]
    affiliateTierId: ID
    affiliateUserId: ID
    userId: ID
    name: String
    permissions: Int
    roles: [UserRole]
    email: String
    steamId: String
    trader: Boolean
    minTotalCommissionEarnt: Float
    maxTotalCommissionEarnt: Float
  ): UserConnection!
  walletChange(id: ID!): WalletChange
  walletChanges(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WalletChangeOrderBy]
    type: [WalletChangeType!]
    userId: ID
  ): WalletChangeConnection!
  walletChangesSummary(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [WalletChangesSummaryOrderBy]
    maxDate: SequelizeDate
    minDate: SequelizeDate
    userId: ID
  ): WalletChangesSummaryConnection!
  wallet(id: ID!): Wallet
  wallets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WalletOrderBy]
    userId: ID
    name: [WalletType!]
  ): WalletConnection!
  waxPeerItems(
    after: String
    first: PaginationAmount
    orderBy: WaxPeerItemOrderBy
    discount: Int
    from: Float
    marketHashName: String
    markup: Int
    maxValue: Float
    minValue: Float
  ): WaxPeerItemConnection!
  waxPeerTrade(id: ID!): WaxPeerTrade
  waxPeerTrades(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WaxPeerTradeOrderBy]
    externalId: String
    externalStatus: WaxPeerTradeExternalStatus
    itemVariantId: ID
    status: WaxPeerTradeStatus
    userId: ID
    waxPeerTradeId: ID
  ): WaxPeerTradeConnection!
  withdrawalRequest(id: ID!): WithdrawalRequest
  withdrawalRequests(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WithdrawalRequestOrderBy]
    userId: ID
    createdFrom: String
    status: WithdrawalRequestStatus
  ): WithdrawalRequestConnection!
  zbtMarketplaceItems(
    steamAppName: SteamAppName!
    after: String
    first: PaginationAmount
    marketHashName: String
    maxValue: Float
    minValue: Float
    orderBy: ZbtMarketplaceItemOrderBy
  ): ZbtMarketplaceItemConnection!
  zbtTrade(id: ID!): ZbtTrade
  zbtTrades(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ZbtTradeOrderBy]
    externalId: String
    externalStatus: ZbtTradeExternalStatus
    itemVariantId: ID
    status: ZbtTradeStatus
    userId: ID
    zbtTradeId: ID
  ): ZbtTradeConnection!
  zincOrder(id: ID!): ZincOrder
  zincOrders(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ZincOrderOrderBy]
    creatorId: ID
    orderId: ID
    zincOrderId: ID
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
  ): ZincOrderConnection!
  zincProductSearch(input: ZincProductSearchInput!): ZincProductSearchPayload!
}

type Mutation {
  createAchievement(input: CreateAchievementInput!): CreateAchievementPayload!
  updateAchievement(
    id: ID!
    input: UpdateAchievementInput!
  ): UpdateAchievementPayload!
  deleteAchievement(id: ID!): DeleteAchievementPayload!
  flushAchievementCache(
    input: FlushAchievementCacheInput
  ): FlushAchievementCachePayload
  cancelAffiliateLoan(
    input: AffiliateLoanCancelInput!
  ): CreateLoanRequestPayload!
  requestAffiliateLoan(
    input: AffiliateLoanRequestInput!
  ): CreateLoanRequestPayload!
  respondToAffiliateLoan(
    input: AffiliateLoanResponseToInput!
  ): UpdateLoanRequestPayload!
  cleanAffiliatePromoImages(input: AffiliateSecretInput!): AffiliateUrlsPayload
  createAffiliatePromoImage(
    input: AffiliatePromoImageInput!
  ): AffiliateUrlPayload
  createAffiliateReports(
    input: AffiliateReportJobInput
  ): CreateAffiliateReportsJobPayload
  createBet(input: CreateBetInput!): CreateBetPayload
  refreshCachedGameBets(
    input: RefreshCachedGameBetsInput!
  ): RefreshCachedGameBetsPayload
  openBox(input: OpenBoxInput!): CreateBoxOpeningPayload
  addRefreshBoxOpeningStreamTasks(
    input: AddRefreshBoxOpeningStreamTasksInput
  ): AddRefreshBoxOpeningStreamTasks!
  refreshBoxOpeningStream(
    input: RefreshBoxOpeningStreamInput
  ): RefreshBoxOpeningStream!
  createBox(input: CreateBoxInput!): CreateBoxPayload
  updateBox(input: UpdateBoxInput!): UpdateBoxPayload
  refreshBoxes(input: RefreshBoxesInput!): RefreshBoxesPayload!
  updateBoxOrder(input: UpdateBoxOrderInput!): UpdateBoxOrderPayload!
  recalculateBoxStatistics(
    input: RecalculateBoxStatisticsInput!
  ): RecalculateBoxStatisticsPayload!
  createCalendarEntry(
    input: CreateCalendarEntryInput!
  ): CreateCalendarEntryPayload
  createCalendar(input: CreateCalendarInput!): CreateCalendarPayload
  deleteCalendar(input: DeleteCalendarInput!): DeleteCalendarPayload
  updateCalendar(input: UpdateCalendarInput!): UpdateCalendarPayload
  createCrashBet(input: CreateCrashBetInput!): CreateCrashBetPayload
  exitCrash(input: ExitCrashInput!): ExitCrashPayload
  createCronJob(input: CreateCronJobInput!): CreateCronJobPayload
  deleteCronJob(input: DeleteCronJobInput!): DeleteCronJobPayload
  pauseCronJob(input: PauseCronJobInput!): PauseCronJobPayload
  resumeCronJob(input: ResumeCronJobInput!): ResumeCronJobPayload
  deleteCacheKey(key: String!): Int
  createDiceBets(input: CreateDiceBetsInput!): CreateDiceBetsPayload
  createDigitalCodes(input: CreateDigitalCodesInput!): CreateDigitalCodePayload
  deleteDigitalCode(id: ID!): DeleteDigitalCodePayload!
  createDocument(input: CreateDocumentInput!): CreateDocumentPayload
  updateDocument(input: UpdateDocumentInput!): UpdateDocumentPayload
  deleteDocument(input: DeleteDocumentInput!): DeleteDocumentPayload
  addEmailToWaitingList(input: EmailWaitingListInput!): EmailWaitingListPayload
  createEmail(input: CreateEmailInput!): CreateEmailPayload
  createExchange(input: CreateExchangeInput!): CreateExchangePayload
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordPayload
  createGameMessage(input: CreateGameMessageInput!): CreateGameMessagePayload
  createPvpGameMessage(
    input: CreatePvpGameMessageInput!
  ): CreatePvpGameMessagePayload
  refreshCachedLatestGames(
    input: RefreshCachedLatestGamesInput!
  ): RefreshCachedLatestGamesPayload
  verifyGame(input: VerifyGameInput!): VerifyGamePayload
  createGemstoneBoost(
    input: CreateGemstoneBoostInput!
  ): CreateGemstoneBoostPayload!
  updateGemstoneBoost(
    input: UpdateGemstoneBoostInput!
  ): UpdateGemstoneBoostPayload!
  createGiveaway(input: CreateGiveawayInput!): CreateGiveawayPayload
  joinGiveaway(input: JoinGiveawayInput!): CreateUserGiveawayPayload
  updateGiveaway(input: UpdateGiveawayInput!): UpdateGiveawayPayload
  announceGiveaway(input: AnnounceGiveawayInput!): AnnounceGiveawayPayload
  createInviteCode(input: CreateInviteCodeInput!): CreateInviteCodePayload
  updateInviteCode(input: UpdateInviteCodeInput!): UpdateInviteCodePayload
  createItemCategory(input: CreateItemCategoryInput): CreateCategoryPayload
  updateItemCategory(input: UpdateItemCategoryInput): UpdateCategoryPayload
  deleteItemCategory(input: DeleteItemCategoryInput): CreateCategoryPayload
  createItemVariant(input: CreateItemVariantInput!): CreateItemVariantPayload
  updateItemVariant(input: UpdateItemVariantInput!): UpdateItemVariantPayload
  deleteItemVariant(input: DeleteItemVariantInput!): DeleteItemVariantPayload
  updateItemVariants(
    input: [UpdateItemVariantInput!]!
    secret: String
    userId: ID
  ): UpdateItemVariantsPayload
  addUpdateItemVariantsTask(
    input: [UpdateItemVariantInput!]!
  ): AddUpdateItemVariantsTaskInputPayload
  cloneItem(input: CloneItemInput!): CloneItemPayload
  createItem(input: CreateItemInput!): CreateItemPayload
  createItems(input: [CreateItemInput!]!): CreateItemsPayload
  flattenItem(input: FlattenItemInput!): FlattenItemPayload
  syncItemPrices(input: SyncItemPricesInput!): SyncItemPricesPayload
  syncNewItems(input: SyncNewItemsInput!): SyncNewItemsPayload
  updateItem(input: UpdateItemInput!): UpdateItemPayload
  updateItemDisplayValues(
    input: UpdateItemDisplayValuesInput!
  ): UpdateItemDisplayValuesPayload
  updateItemExchangeRates(
    input: UpdateItemExchangeRatesInput!
  ): UpdateItemExchangeRatesPayload
  updateItemMarkups(input: UpdateItemMarkupsInput!): UpdateItemMarkupsPayload
  updateItemValues(input: UpdateItemValuesInput!): UpdateItemValuesPayload
  createJackpot(input: CreateJackpotInput!): CreateJackpotPayload
  payoutJackpot: PayoutJackpotPayload
  payoutJackpotTicket(input: PayoutTicketInput!): PayoutJackpotTicketPayload
  recalculateJackpot(input: RecalculateJackpotInput!): RecalculateJackpotPayload
  recalculateJackpotTickets(
    input: RecalculateJackpotTicketsInput!
  ): RecalculateJackpotTicketsPayload
  updateJackpot(input: UpdateJackpotInput!): UpdateJackpotPayload
  completeJackpot(input: CompleteJackpotInput!): CompleteJackpotPayload
  createMarket(input: CreateUpdateMarketInput!): CreateMarketPayload
  updateMarket(id: ID!, input: CreateUpdateMarketInput!): UpdateMarketPayload
  deleteMarket(id: ID!): DeleteMarketPayload
  cloneMarket(id: ID!, input: CreateUpdateMarketInput!): CloneMarketPayload
  processMatchBettingMarket(
    input: ProcessMatchBettingMarketInput!
  ): ProcessMatchBettingMarketPayload
  completeMatchBettingSlip(
    input: CompleteMatchBettingSlipInput!
  ): CompleteMatchBettingSlipPayload
  createMatchBettingSlip(
    input: CreateMatchBettingSlipInput!
  ): CreateMatchBettingSlipPayload
  createMessage(input: CreateMessageInput!): CreateMessagePayload
  deleteMessages(input: DeleteMessagesInput!): DeleteMessagesPayload
  createNote(input: CreateNoteInput!): CreateNotePayload
  createNotificationMessage(
    input: CreateNotificationMessageInput!
  ): CreateNotificationMessagePayload
  markNotificationMessagesAsRead(
    input: MarkNotificationMessagesAsReadInput!
  ): MarkNotificationMessagesAsReadPayload
  markNotificationsAsRead(
    input: MarkNotificationsAsReadInput!
  ): MarkNotificationsAsReadPayload
  createOrderNote(input: CreateOrderNoteInput!): CreateOrderNotePayload
  createOrder(input: CreateOrderInput!): CreateOrderPayload
  updateOrder(input: UpdateOrderInput!): UpdateOrderPayload
  deleteOrder(input: DeleteOrderInput!): DeleteOrderPayload
  sendOrderDeliveredEmail(
    input: SendOrderDeliveredEmailInput!
  ): SendOrderDeliveredEmailPayload
  createAffiliatePromoCode(
    input: CreateAffiliatePromoCodeInput
  ): CreateAffiliatePromoCodePayload!
  updateAffiliatePromoCode(
    input: UpdateAffiliatePromoCodeInput
  ): UpdateAffiliatePromoCodePayload!
  createPromoCodes(input: CreatePromoCodeInput): CreatePromoCodesPayload!
  deletePromoCode(input: DeletePromoCodeInput): PromoCodePayload!
  updatePromoCode(input: UpdatePromoCodeInput): PromoCodePayload!
  usePromoCode(input: UsePromoCodeInput!): PromoCodePayload!
  callPvpBot(input: CallPvpBotInput!): CallPvpBotPayload
  callPvpBotForRematch(
    input: CallPvpBotForRematchInput!
  ): CallPvpBotForRematchPayload
  createPvpBot(input: CreatePvpBotInput!): CreatePvpBotPayload
  updatePvpBot(input: UpdatePvpBotInput!): UpdatePvpBotPayload
  cleanUpStalePvpGames(
    input: CleanUpStalePvpGamesInput!
  ): CleanUpStalePvpGamesPayload
  createPvpGame(input: CreatePvpGameInput!): CreatePvpGamePayload
  exitPvpGame(input: ExitPvpGameInput!): ExitPvpGamePayload
  joinPvpGame(input: JoinPvpGameInput!): JoinPvpGamePayload
  playPvpGame(input: PlayPvpGameInput!): PlayPvpGamePayload
  createPvpRound(input: CreatePvpRoundInput!): CreatePvpRoundPayload
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  changeSeed(input: ChangeSeedInput!): ChangeSeedPayload
  updateSetting(input: UpdateSettingInput!): UpdateSettingPayload
  flushSettingCache(input: FlushSettingInput): FlushSettingCachePayload
  banSteamBotAssets(input: BanSteamBotAssetsInput!): BanSteamBotAssetsPayload
  updateAvailableAssets(
    input: UpdateAvailableAssetsInput!
  ): UpdateAvailableAssetsPayload
  checkSteamBotActivity(
    input: CheckSteamBotActivityInput!
  ): CheckSteamBotActivityPlayload!
  createSteamBot(input: CreateUpdateSteamBotInput!): CreateSteamBotPayload!
  createSteamBots(input: [CreateUpdateSteamBotInput!]!): CreateSteamBotsPayload!
  updateSteamBot(
    id: ID!
    input: CreateUpdateSteamBotInput!
  ): UpdateSteamBotPayload!
  deleteSteamBot(id: ID!): DeleteSteamBotPayload!
  wakeUpSteamBot(id: ID!): WakeUpSteamBotPayload!
  sleepSteamBot(id: ID!): SleepSteamBotPayload!
  deleteSteamOffer(id: ID!): DeleteSteamOfferPayload
  readySteamOffer(input: ReadySteamOfferInput!): ReadySteamOfferPayload!
  createSteamOffers(input: CreateSteamOffersInput!): CreateSteamOffersPayload!
  updateSteamStatus(input: UpdateSteamStatusInput!): UpdateSteamStatusPayload
  createSupportTicket(
    input: CreateSupportTicketInput!
  ): CreateSupportTicketPayload
  createTag(input: CreateTagInput): CreateTagPayload
  updateTag(input: UpdateTagInput): UpdateTagPayload
  deleteTag(input: DeleteTagInput): DeleteTagPayload
  purgeTaskQueue(input: PurgeTaskQueueInput!): PurgeTaskQueuePayload
  autoJoinTrade(input: AutoJoinTradeInput!): AutoJoinTradePayload
  cancelTrade(input: CancelTradeInput!): CancelTradePayload
  cleanUpTrades(input: CleanUpTradesInput!): CleanUpTradesPayload
  cleanUpCooldownTrades(
    input: CleanUpCooldownTradesInput!
  ): CleanUpCooldownTradesPayload
  completeTrade(input: CompleteTradeInput!): CompleteTradePayload
  createTrade(input: CreateTradeInput!): CreateTradePayload
  joinTrade(input: JoinTradeInput!): JoinTradePayload
  joinTrades(input: JoinTradesInput!): JoinTradesPayload
  processTrade(input: ProcessTradeInput!): ProcessTradePayload
  trackTrade(input: TrackTradeInput!): TrackTradePayload
  updateTradesMarkup(input: UpdateTradesMarkupInput!): UpdateTradesMarkupPayload
  approveWithdrawalTransaction(
    input: ApproveWithdrawalTransactionInput!
  ): ApproveWithdrawalTransactionPayload
  createTransaction(input: CreateTransactionInput!): CreateTransactionPayload
  updateTransaction(input: UpdateTransactionInput!): UpdateTransactionPayload
  claimUserAchievement(
    input: ClaimUserAchievementInput!
  ): ClaimUserAchievementPayload
  createUserAchievement(
    input: CreateUserAchievementInput!
  ): CreateUserAchievementPayload
  triggerUserAchievement(
    input: TriggerUserAchievementInput!
  ): TriggerUserAchievementPayload
  flushUserAchievementCache(
    input: FlushUserAchievementCacheInput!
  ): FlushUserAchievementCachePayload
  purchaseBox(input: PurchaseBoxInput!): PurchaseBoxPayload
  refundUserBox(input: RefundUserBoxInput!): RefundUserBoxPayload
  createUserCommunication(
    input: CreateUserCommunicationInput!
  ): CreateUserCommunicationPayload
  deleteUserCommunication(
    input: DeleteUserCommunicationInput!
  ): DeleteUserCommunicationPayload
  checkUserItemStatus(
    input: CheckUserItemStatusInput!
  ): CheckUserItemStatusPayload
  updateUserItem(input: UpdateUserItemInput!): UpdateUserItemPayload
  updateUserItemShipTo(input: UpdateUserItemShipToInput!): UpdateUserItemPayload
  updateUserPreferences(
    input: UpdateUserPreferencesInput!
  ): UpdateUserPreferencesPayload
  purchaseXp(input: PurchaseXpInput!): PurchaseXpPayload!
  login(email: String, password: String): LoginPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  updateUserEmail(input: UpdateUserEmailInput!): UpdateUserEmailPayload
  revertUser(input: RevertUserInput!): RevertUserPayload
  acceptTos(input: AcceptTosInput!): AcceptTosPayload
  updateSuspectedTrader(
    input: UpdateSuspectedTraderInput!
  ): UpdateSuspectedTraderPayload
  sendValidationEmail(
    input: SendValidationEmailInput!
  ): SendValidationEmailPayload
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayload
  claimAffiliateWallet(input: AffiliateClaimAmountInput!): UpdateWalletPayload
  updateWallet(input: UpdateWalletInput!): UpdateWalletPayload
  createWaxPeerTrade(input: CreateWaxPeerTradeInput!): CreateWaxPeerTradePayload
  trackWaxPeerTrade(input: TrackWaxPeerTradeInput!): TrackWaxPeerTradePayload
  createWithdrawalRequest(
    input: CreateWithdrawalRequestInput!
  ): CreateWithdrawalRequestPayload
  updateWithdrawalRequest(
    input: UpdateWithdrawalRequestInput!
  ): UpdateWithdrawalRequestPayload
  increaseWithdrawalRequestAmount(
    input: IncreaseWithdrawalRequestInput!
  ): IncreaseWithdrawalRequestPayload
  cancelZbtTrade(input: CancelZbtTradeInput!): CancelZbtTradePayload
  createZbtTrade(input: CreateZbtTradeInput!): CreateZbtTradePayload
  trackZbtTrade(input: TrackZbtTradeInput!): TrackZbtTradePayload
  abortZincOrder(input: AbortZincOrderInput!): AbortZincOrderPayload
  cancelZincOrder(input: CancelZincOrderInput!): CancelZincOrderPayload
  createZincOrder(input: CreateZincOrderInput!): CreateZincOrderPayload
  retryZincOrder(input: RetryZincOrderInput!): RetryZincOrderPayload
}

input CreateAchievementInput {
  autoClaim: Boolean
  description: String!
  enabled: Boolean!
  imageUrl: String!
  limitPerUser: Int
  name: String!
  rewards: [AchievementRewardInput!]!
  rewardsExpireAfterSeconds: Int!
  trigger: AchievementTriggerInput
  type: AchievementType
}

input UpdateAchievementInput {
  autoClaim: Boolean
  description: String
  enabled: Boolean
  imageUrl: String
  limitPerUser: Int
  name: String
  rewards: [AchievementRewardInput!]!
  rewardsExpireAfterSeconds: Int
  trigger: AchievementTriggerInput
}

input FlushAchievementCacheInput {
  unused: Boolean
}

enum AchievementOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum AchievementType {
  CHAT_MESSAGE
  LOST_WAGER_ON_GAME
  TWITTER_FOLLOWER
  WAGER_ON_GAME
}

type AffiliateBlogPostResult {
  id: String!
  url: String!
  title: String!
  image: String
  date: SequelizeDate
  tags: [String]
}

type AffiliateBlogPostsPayload {
  posts: [AffiliateBlogPostResult]
}

type AffiliateUrlsPayload {
  urls: [String!]
}

type AffiliateUrlPayload {
  url: String!
}

input AffiliateBlogInput {
  count: Int!
  tags: [String]
}

input AffiliatePromoImageIdentifier {
  id: ID!
}

input AffiliatePromoImageInput {
  file: Upload!
}

type AffiliateLoanRequest implements Node {
  id: ID!
  userId: ID!
  user: User
  acceptedByUserId: ID
  acceptedBy: User
  amount: Float!
  currency: String!
  description: String!
  status: AffiliateLoanStatus!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type AffiliateLoanRequestConnection {
  edges: [AffiliateLoanRequestEdge]
  pageInfo: PageInfo!
  total: Int
}

type AffiliateLoanRequestEdge {
  cursor: String!
  node: AffiliateLoanRequest
}

type CreateLoanRequestPayload {
  affiliateLoanRequest: AffiliateLoanRequest
}

type UpdateLoanRequestPayload {
  affiliateLoanRequest: AffiliateLoanRequest
}

type Subscription {
  createAffiliateLoanRequest: CreateLoanRequestPayload!
  updateAffiliateLoanRequest: UpdateLoanRequestPayload!
  createBet(userId: ID): CreateBetSubscriptionPayload!
  refreshCachedGameBets: RefreshCachedGameBetsSubscriptionPayload!
  createBoxOpening(
    ancestorBoxId: ID
    boxId: ID
    boxSlug: String
    minItemValue: Float
  ): CreateBoxOpeningSubscriptionPayload!
  createBox: CreateBoxSubscriptionPayload
  updateBox: UpdateBoxSubscriptionPayload
  createCalendarEntry: CreateCalendarEntrySubscriptionPayload
  createCalendar: CreateCalendarSubscriptionPayload
  updateCalendar: UpdateCalendarSubscriptionPayload
  deleteCalendar: DeleteCalendarSubscriptionPayload
  createCrashBet: CreateCrashBetSubscriptionPayload!
  updateCrashBet(id: ID): UpdateCrashBetSubscriptionPayload!
  createCrashGame: CreateCrashGameSubscriptionPayload
  updateCrashGame: UpdateCrashGameSubscriptionPayload
  createDiceBets: CreateDiceBetsSubscriptionPayload!
  createDigitalCode: CreateDigitalCodeSubscriptionPayload!
  updateDigitalCode: UpdateDigitalCodeSubscriptionPayload!
  deleteDigitalCode: DeleteDigitalCodeSubscriptionPayload!
  createDocument: CreateDocumentSubscriptionPayload
  deleteDocument: DeleteDocumentSubscriptionPayload
  createGameJackpot: CreateGameJackpotSubscriptionPayload!
  updateGameJackpot(id: ID): UpdateGameJackpotSubscriptionPayload!
  createGameMessage(gameId: ID): CreateGameMessageSubscriptionPayload!
  createPvpGameMessage(pvpGameId: ID): CreatePvpGameMessageSubscriptionPayload!
  createGame: CreateGameSubscriptionPayload!
  refreshCachedLatestGames: RefreshCachedLatestGamesSubscriptionPayload!
  updateGame: UpdateGameSubscriptionPayload!
  createGemstoneBoostActivation: CreateGemstoneBoostActivationPayload!
  updateGemstoneBoostInfo: UpdateGemstoneBoostSubscriptionPayload
  winGemstones: WinGemstoneSubscription!
  createGiveaway: CreateGiveawayPayload!
  updateGiveaway: UpdateGiveawayPayload!
  createItemCategory: CreateItemCategorySubscriptionPayload!
  updateItemCategory: UpdateItemCategorySubscriptionPayload!
  deleteItemCategory: DeleteItemCategorySubscriptionPayload!
  createItemVariant: CreateItemVariantSubscriptionPayload!
  updateItemVariant: UpdateItemVariantSubscriptionPayload!
  deleteItemVariant: DeleteItemVariantSubscriptionPayload!
  createItem: CreateItemSubscriptionPayload!
  updateItem: UpdateItemSubscriptionPayload!
  createJackpotWinningTicket: JackpotWinningTicketSubscriptionPayload!
  createJackpot: CreateJackpotSubscriptionPayload!
  updateJackpot(id: ID): UpdateJackpotSubscriptionPayload!
  createMatchBettingGame: CreateMatchBettingGameSubscriptionPayload!
  updateMatchBettingGame: UpdateMatchBettingGameSubscriptionPayload!
  createMatchBettingLeague: CreateMatchBettingLeagueSubscriptionPayload!
  updateMatchBettingLeague: UpdateMatchBettingLeagueSubscriptionPayload!
  createMatchBettingMarket: CreateMatchBettingMarketSubscriptionPayload!
  updateMatchBettingMarket: UpdateMatchBettingMarketSubscriptionPayload!
  createMatchBettingMatch(
    name: String
    status: MatchBettingMatchStatus
    videoGame: MatchBettingVideoGame
  ): CreateMatchBettingMatchSubscriptionPayload!
  updateMatchBettingMatch(
    id: ID
    name: String
    status: MatchBettingMatchStatus
    videoGame: MatchBettingVideoGame
  ): UpdateMatchBettingMatchSubscriptionPayload!
  createMatchBettingPlayer: CreateMatchBettingPlayerSubscriptionPayload!
  updateMatchBettingPlayer: UpdateMatchBettingPlayerSubscriptionPayload!
  createMatchBettingSerie: CreateMatchBettingSerieSubscriptionPayload!
  updateMatchBettingSerie: UpdateMatchBettingSerieSubscriptionPayload!
  createMatchBettingSlip(
    status: MatchBettingSlipStatus
    userId: ID
  ): CreateMatchBettingSlipSubscriptionPayload!
  updateMatchBettingSlip(
    id: ID
    status: MatchBettingSlipStatus
    userId: ID
  ): UpdateMatchBettingSlipSubscriptionPayload!
  createMatchBettingTeam: CreateMatchBettingTeamSubscriptionPayload!
  updateMatchBettingTeam: UpdateMatchBettingTeamSubscriptionPayload!
  createMatchBettingTournament: CreateMatchBettingTournamentSubscriptionPayload!
  updateMatchBettingTournament: UpdateMatchBettingTournamentSubscriptionPayload!
  createMessage(channel: String!): CreateMessageSubscriptionPayload!
  deleteMessage(channel: String!): DeleteMessageSubscriptionPayload!
  createNotificationMessage: CreateNotificationMessageSubscriptionPayload!
  updateNotificationMessage: UpdateNotificationMessageSubscriptionPayload!
  createNotification: CreateNotificationSubscriptionPayload!
  updateNotification: UpdateNotificationSubscriptionPayload!
  createOrder: CreateOrderSubscriptionPayload!
  updateOrder: UpdateOrderSubscriptionPayload!
  deleteOrder: DeleteOrderSubscriptionPayload!
  createPromoCode: CreatePromoCodeSubscriptionPayload!
  updatePromoCode(
    code: String!
    marketId: ID!
  ): UpdatePromoCodeSubscriptionPayload!
  deletePromoCode: DeletePromoCodeSubscriptionPayload!
  createPvpBet: CreatePvpBetSubscriptionPayload!
  updatePvpBet: UpdatePvpBetSubscriptionPayload!
  createPvpBot: CreatePvpBotSubscriptionPayload!
  updatePvpBot: UpdatePvpBetSubscriptionPayload!
  createPvpGame: CreatePvpGameSubscriptionPayload!
  playPvpGame: PlayPvpGameSubscriptionPayload!
  updatePvpGame(id: ID, userId: ID): UpdatePvpGameSubscriptionPayload!
  createPvpRound(pvpGameId: ID): CreatePvpRoundSubscriptionPayload!
  updatePvpRound(id: ID, pvpGameId: ID): UpdatePvpRoundSubscriptionPayload!
  createRoll: CreateRollSubscriptionPayload!
  onlineCount: Int
  updateSetting: UpdateSettingSubscriptionPayload!
  flushSettingCache: String
  createSteamAsset: CreateSteamAssetSubscriptionPayload!
  updateSteamAsset(id: ID): UpdateSteamAssetSubscriptionPayload!
  deleteSteamAsset: DeleteSteamAssetSubscriptionPayload!
  createSteamBot: CreateSteamBotSubscriptionPayload!
  updateSteamBot: UpdateSteamBotSubscriptionPayload!
  deleteSteamBot: DeleteSteamBotSubscriptionPayload!
  createSteamOffer: CreateSteamOfferSubscriptionPayload
  updateSteamOffer(id: ID): UpdateSteamOfferSubscriptionPayload
  deleteSteamOffer: DeleteSteamOfferSubscriptionPayload
  createTag: CreateTagSubscriptionPayload!
  updateTag: UpdateTagSubscriptionPayload!
  deleteTag: DeleteTagSubscriptionPayload!
  createTicket(userId: ID): CreateTicketSubscriptionPayload!
  createTrade(userId: ID): CreateTradeSubscriptionPayload!
  updateTrade(status: TradeStatus, userId: ID): UpdateTradeSubscriptionPayload!
  removeFromListedTrade: RemoveFromListedTradeSubscriptionPayload!
  createTransaction: CreateTransactionSubscriptionPayload!
  updateTransaction(id: ID): UpdateTransactionSubscriptionPayload!
  createUserAchievement(userId: ID): CreateUserAchievementSubscriptionPayload!
  updateUserAchievement: UpdateUserAchievementSubscriptionPayload!
  createUserBox: CreateUserBoxSubscriptionPayload!
  updateUserBox: UpdateUserBoxSubscriptionPayload!
  createUserCommunication: CreateUserCommunicationSubscriptionPayload!
  deleteUserCommunication: DeleteUserCommunicationSubscriptionPayload!
  createUserGiveaway: CreateUserGiveawayPayload!
  updateUserGiveaway: UpdateUserGiveawayPayload!
  createUserItem: CreateUserItemSubscriptionPayload!
  updateUserItem: UpdateUserItemSubscriptionPayload!
  deleteUserItem: DeleteUserItemSubscriptionPayload!
  updateUserProgress: UpdateUserProgressSubscriptionPayload
  createUser: CreateUserSubscriptionPayload!
  updateUser: UpdateUserSubscriptionPayload!
  authenticatedUser: AuthenticatedUserSubscriptionPayload!
  updateWallet: UpdateWalletSubscriptionPayload!
  createWaxPeerTrade: CreateWaxPeerTradeSubscriptionPayload!
  updateWaxPeerTrade: UpdateWaxPeerTradeSubscriptionPayload!
  createWithdrawalRequest: CreateWithdrawalRequestSubscriptionPayload!
  updateWithdrawalRequest: UpdateWithdrawalRequestSubscriptionPayload!
  createZbtTrade: CreateZbtTradeSubscriptionPayload!
  updateZbtTrade: UpdateZbtTradeSubscriptionPayload!
  createZincOrder: CreateZincOrderSubscriptionPayload!
  updateZincOrder: UpdateZincOrderSubscriptionPayload!
  deleteZincOrder: DeleteZincOrderSubscriptionPayload!
}

input AffiliateLoanRequestArgs {
  acceptedByUserId: ID
  amount: Float
  createdAt: SequelizeDate
  currency: String
  description: String
  limit: Int
  offset: Int
  orderBy: [AffiliateLoanRequestOrderBy]
  page: Int
  status: AffiliateLoanStatus
  userId: ID
}

input AffiliateLoanResponseToInput {
  id: ID!
  status: AffiliateLoanStatus!
}

input AffiliateLoanCancelInput {
  id: ID!
}

input AffiliateLoanRequestInput {
  amount: Int!
  currency: String!
  description: String!
}

enum AffiliateLoanStatus {
  ACCEPTED
  CANCELLED
  REJECTED
  WAITING
}

enum AffiliateLoanRequestOrderBy {
  ACCEPTED_BY_USER_ID
  ACCEPTED_BY_USER_ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DESCRIPTION
  DESCRIPTION_DESC
  ID
  ID_DESC
  STATUS
  STATUS_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  USER_ID
  USER_ID_DESC
}

type AffiliateUserSummary {
  avatar: String
  displayName: String
  xp: String
}

type Tracker {
  count: Int!
  date: SequelizeDate
  index: Int
}

type TrackerTimeSeries {
  status: UserAffiliateStatus!
  timeSeries: [Tracker]!
}

type RefereeActivityResult {
  active: TrackerTimeSeries!
  stealable: TrackerTimeSeries!
  retargetable: TrackerTimeSeries!
  unconverted: TrackerTimeSeries!
}

type AffiliateAllTime {
  affiliateUserId: ID
  avatar: String
  commission: Float
  deposited: Float
  displayName: String
  hideSteamProfile: Boolean
  lastActiveAt: SequelizeDate
  lastDepositAt: SequelizeDate
  level: Int
  refereeId: ID
  status: UserAffiliateStatus
  url: String
  wageredTotal: Float
}

type AffiliateAllTimeResult {
  edges: [AffiliateAllTimeEdge]
  pageInfo: PageInfo!
  pages: [String]
  total: Int
}

type AffiliateAllTimeEdge {
  cursor: String
  node: AffiliateAllTime
}

type AffiliateEarningsResult {
  commission: Float
  date: SequelizeDate
  deposited: Float
  wageredBoxOpen: Float
  wageredCrash: Float
  wageredDice: Float
  wageredRoulette: Float
  wageredPvp: Float
  wageredMatchBetting: Float
  wageredTotal: Float
}

type TotalCommisionGivenAwayPayload {
  amount: Float!
}

type RefereeDailyActivityResult {
  timeSeries: [Tracker!]!
}

type AffiliateStatusCountResult {
  affiliateUserId: ID!
  active: Int!
  stealable: Int!
  retargetable: Int!
  total: Int!
  totalAllTime: Int!
  unconverted: Int!
}

type CreateAffiliateReportsJobPayload {
  status: Boolean
}

type AffiliateActiveCountResult {
  count: Int!
}

type RefereeStatusResult {
  status: UserAffiliateStatus
  secondsLeft: Int
}

input AffiliateUserIdentifier {
  affiliateUserId: ID!
}

input AffiliateReportJobInput {
  reportType: JobType
  secret: String
}

input RefereeStatusInput {
  id: ID!
}

input RefereeActivityInput {
  affiliateUserId: ID!
  dateRange: AffiliateReportType
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateAllTimeInput {
  affiliateUserId: ID!
  after: String
  before: String
  first: PaginationAmount
  last: PaginationAmount
  limit: PaginationAmount
  orderBy: [AffiliateReportAllTimeOrderBy]
  page: Int
  status: UserAffiliateStatus
}

input AffiliateEarningsInput {
  affiliateUserId: ID!
  startDate: SequelizeDate
  endDate: SequelizeDate
}

input AffiliateStatusCountsInput {
  affiliateUserId: ID!
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input RefereeDailyActivityInput {
  affiliateUserId: ID!
  dateRange: AffiliateReportType
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateActiveCountInput {
  affiliateUserId: ID
  endDate: SequelizeDate
  startDate: SequelizeDate
}

input AffiliateSecretInput {
  secret: String!
}

enum UserAffiliateStatus {
  ACTIVE
  STEALABLE
  RETARGETABLE
  STOLEN
  UNCONVERTED
}

enum AffiliateReportType {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

enum JobType {
  FULL
  PARTIAL
}

enum AffiliateReportAllTimeOrderBy {
  AFFILIATE_STATUS
  AFFILIATE_STATUS_DESC
  COMMISSION
  COMMISSION_DESC
  DEPOSIT
  DEPOSIT_DESC
  DISPLAY_NAME
  DISPLAY_NAME_DESC
  ID
  ID_DESC
  LAST_ACTIVE_AT
  LAST_ACTIVE_AT_DESC
  WAGERED_BOX_OPEN
  WAGERED_BOX_OPEN_DESC
  WAGERED_CRASH
  WAGERED_CRASH_DESC
  WAGERED_DICE
  WAGERED_DICE_DESC
  WAGERED_ROLL
  WAGERED_ROLL_DESC
  WAGERED_PVP
  WAGERED_PVP_DESC
  WAGERED_TOTAL
  WAGERED_TOTAL_DESC
}

type AffiliateSearch implements Node {
  affiliateTier: AffiliateTier
  affiliateTierId: Int
  avatar: String
  displayName: String
  id: ID!
  lastActiveAt: SequelizeDate
  market: Market
  marketId: Int
  totalCommissionEarnt: Float
  totalDepositOfReferredUsers: Float
  totalDepositorsReferred: Int
  totalUsersReferred: Int
  totalWithdrawOfReferredUsers: Float
  user: User
  xp: BigInt
}

type AffiliateSearchEdge {
  cursor: String!
  node: AffiliateSearch
}

type AffiliateSearchConnection {
  edges: [AffiliateSearchEdge]
  pageInfo: PageInfo!
  pages: [String]
  total: Int
}

input AffiliateSearchInputs {
  affiliateTierId: Int
  after: String
  before: String
  displayName: String
  first: Int
  fuzzy: Float
  id: ID
  last: Int
  lastActiveAt: SequelizeDate
  limit: Int
  marketId: Int
  orderBy: [AffiliateSearchOrderBy]
  page: Int
  totalCommissionEarnt: Float
  totalDepositOfReferredUsers: Float
  totalDepositorsReferred: Int
  totalUsersReferred: Int
  totalWithdrawOfReferredUsers: Float
}

enum AffiliateSearchOrderBy {
  COMMISSION
  COMMISSION_DESC
  DISPLAY_NAME
  DISPLAY_NAME_DESC
  ID
  ID_DESC
  LAST_ACTIVE_AT
  LAST_ACTIVE_AT_DESC
  MARKET
  MARKET_DESC
  TIER
  TIER_DESC
  TOTAL_DEPOSIT
  TOTAL_DEPOSIT_DESC
  TOTAL_DEPOSIT_USERS
  TOTAL_DEPOSIT_USERS_DESC
  TOTAL_USERS
  TOTAL_USERS_DESC
  TOTAL_WITHDRAW
  TOTAL_WITHDRAW_DESC
}

type AffiliateTier implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  name: String!
  commissionRequirement: Float
  depositRequirement: Float!
  stickyReferees: Boolean!
  commissionPercentage: Float!
  roulettePercentage: Float!
  unboxingPercentage: Float!
  crashPercentage: Float!
  dicePercentage: Float!
  pvpPercentage: Float!
  depositPercentage: Float!
  loanLimit: Int
  promoCodeLimit: Int
  minimumReferralsClaimRequirement: Int
  minimumActiveReferralsClaimRequirement: Int
  ancestorAffiliateTierId: ID!
}

type AffiliateTierConnection {
  pageInfo: PageInfo!
  edges: [AffiliateTierEdge]
  total: Int
}

type AffiliateTierEdge {
  node: AffiliateTier
  cursor: String!
}

enum AffiliateTierOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  COMMISSION_REQUIREMENT
  COMMISSION_REQUIREMENT_DESC
}

type Asset implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate!
  url: String!
  mimeType: String!
  fileName: String!
  fileSize: String!
  width: String
  height: String
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]
  total: Int
}

type AssetEdge {
  node: Asset
  cursor: String!
}

enum AssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type AvailableAsset {
  steamAssetId: ID!
  steamAsset: SteamAsset
  availableAt: SequelizeDate
}

type Bet implements Node {
  id: ID!
  selection: Int
  selections: [Int!]
  mode: BetMode
  amount: Float!
  payout: Float
  payoutMultiplier: Float
  currency: String!
  gameId: ID
  game: Game
  userId: ID
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  type: BetType!
  processed: Boolean!
  rollValue: Int
}

type BetConnection {
  pageInfo: PageInfo!
  edges: [BetEdge]
  total: Int
}

type BetEdge {
  node: Bet
  cursor: String!
}

type CreateBetPayload {
  bet: Bet!
}

type RefreshCachedGameBetsPayload {
  success: Boolean!
}

type CreateBetSubscriptionPayload {
  bet: Bet!
}

type RefreshCachedGameBetsSubscriptionPayload {
  gameId: ID!
  success: Boolean
}

input CreateBetInput {
  amount: Float!
  gameId: ID!
  mode: BetMode
  selection: Int
  selections: [Int!]
}

input RefreshCachedGameBetsInput {
  gameId: ID!
  secret: String
}

enum BetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
}

enum BetMode {
  NORMAL
  CRAZY
}

enum BetType {
  LEGACY
  MODERN
}

type BoxOpeningMeta {
  userIsPvpBot: Boolean
  xpRewarded: Float
}

type BoxOpening implements Node {
  id: ID!
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  deletedAt: SequelizeDate
  boxValue: Float!
  itemValue: Float!
  profit: Float!
  currency: String!
  boxId: ID!
  itemVariantId: ID!
  userItemId: ID
  userId: ID!
  rollId: ID!
  userBoxId: ID!
  boxItemId: ID!
  box: Box
  itemVariant: ItemVariant
  userItem: UserItem
  user: User
  roll: Roll
  userBox: UserBox
  ticketsWon: Int!
  pvpGame: PvpGame
  pvpGameId: ID
  pvpBet: PvpBet
  pvpBetId: ID
  lostToUser: User
  lostToUserId: ID
  meta: BoxOpeningMeta
  pfVersion: ProvablyFairVersion
}

type BoxOpeningConnection {
  pageInfo: PageInfo!
  edges: [BoxOpeningEdge]
  total: Int
}

type BoxOpeningEdge {
  node: BoxOpening
  cursor: String!
}

type BoxStat {
  openCount: Int
  profit: Float
  averageProfit: Float
  itemValue: Float
  totalAcquiredValue: Float
  totalConsumedValue: Float
  totalOrderCost: Float
  box: Box
}

type BoxItemVariantStat {
  obtained: Int
  consumed: Int
  exchanged: Int
  requested: Int
  processing: Int
  ordered: Int
  available: Int
  itemVariant: ItemVariant
  orderCost: Float
}

type CreateBoxOpeningPayload {
  box: Box
  boxOpenings: [BoxOpening]
}

type CreateBoxOpeningSubscriptionPayload {
  boxOpening: BoxOpening!
}

type LuckiestBoxOpening {
  boxOpening: BoxOpening
  totalOpenings: Int!
}

type RefreshBoxOpeningStream {
  boxOpeningsByTime: [BoxOpening!]!
  boxOpeningsByValue: [BoxOpening!]!
}

type AddRefreshBoxOpeningStreamTasks {
  success: Boolean!
}

input CreateBoxOpeningItemInput {
  id: ID!
  rate: Float!
}

input OpenBoxInput {
  boxId: ID!
  amount: Int
}

input AddRefreshBoxOpeningStreamTasksInput {
  refreshForCache: [AddRefreshBoxOpeningStreamTasksForCache!]!
}

input RefreshBoxOpeningStreamInput {
  ancestorBoxId: ID
  boxSlug: String
  secret: String
}

enum BoxOpeningOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  ITEM_VALUE
  ITEM_VALUE_DESC
  BOX_VALUE
  BOX_VALUE_DESC
}

enum AddRefreshBoxOpeningStreamTasksForCache {
  ALL_BOXES
  ANCESTOR_BOX_ID
  BOX_SLUG
}

type Box implements Node {
  id: ID!
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  deletedAt: SequelizeDate
  enabled: Boolean
  levelRequired: Int!
  free: Boolean
  purchasable: Boolean
  openable: Boolean
  sellable: Boolean
  giveJackpotTicket: Boolean
  ticketsRewarded: Int!
  order: Int
  type: BoxType
  name: String
  slug: String
  description: String
  iconUrl: String
  price: Float
  priceFixed: Float
  expectedValue: Float
  houseEdgePercent: Float
  maxPurchasesDaily: Int
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  walletRestrictions: [WalletType]
  cost: Float
  currency: String!
  creatorId: ID
  unopenedUserBoxesCount: Int
  creator: User
  ancestorBoxId: ID!
  marketId: ID!
  market: Market
  ancestorBox: Box
  tags: [Tag]
  slots: [BoxSlot!]!
  totalBoxOpenings: Int!
  totalSpent: Float
  totalProfit: Float
  averageProfit: Float
  totalUnboxedValue: Float
  backgroundImageUrl: String
  discountPrice: Float
  discountPercent: Float!
  originalPrice: Float!
  userLastPurchasedAt: SequelizeDate
  pfVersion: ProvablyFairVersion
}

type BoxConnection {
  pageInfo: PageInfo!
  edges: [BoxEdge]
  total: Int
}

type BoxEdge {
  node: Box
  cursor: String!
}

type CreateBoxPayload {
  box: Box!
}

type UpdateBoxPayload {
  box: Box!
}

type CreateBoxSubscriptionPayload {
  box: Box!
}

type UpdateBoxSubscriptionPayload {
  box: Box!
}

type RefreshBoxesPayload {
  success: Boolean!
}

type UpdateBoxOrderPayload {
  success: Boolean!
}

type FavouriteBox {
  box: Box
  totalOpenings: Int!
}

type RecalculateBoxStatisticsPayload {
  success: Boolean!
}

type BoxSlot {
  id: ID!
  rate: Float
  rollStart: Float
  rollEnd: Float
  itemId: ID!
  item: Item!
}

input BoxSlotInput {
  itemId: ID!
  rate: Float!
}

input CreateBoxInput {
  description: String!
  discountPrice: Float
  enabled: Boolean!
  iconUrl: String!
  slots: [BoxSlotInput]!
  levelRequired: Int
  marketId: ID
  maxPurchasesDaily: Int
  name: String!
  openable: Boolean
  order: Int
  houseEdgePercent: Float
  priceFixed: Float
  purchasable: Boolean
  sellable: Boolean
  ticketsRewarded: Int
  tags: [String]
  type: BoxType!
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  backgroundImageUrl: String
  walletRestrictions: [WalletType]
}

input UpdateBoxInput {
  description: String
  discountPrice: Float
  enabled: Boolean
  iconUrl: String
  id: ID!
  slots: [BoxSlotInput]
  levelRequired: Int
  marketId: ID
  maxPurchasesDaily: Int
  houseEdgePercent: Float
  name: String
  openable: Boolean
  order: Int
  priceFixed: Float
  purchasable: Boolean
  sellable: Boolean
  ticketsRewarded: Int
  tags: [String]
  type: BoxType
  availableFrom: SequelizeDate
  availableUntil: SequelizeDate
  backgroundImageUrl: String
  walletRestrictions: [WalletType]
}

input UpdateBoxOrderInput {
  boxes: [BoxOrderItem!]!
}

input BoxOrderItem {
  id: ID!
  order: Int!
}

input RefreshBoxesInput {
  marketId: ID!
}

input RecalculateBoxStatisticsInput {
  secret: String
}

enum BoxOrderBy {
  ID
  ID_DESC
  VALUE
  CREATED_AT
  ORDER
  CREATED_AT_DESC
  CREATED_AT_ASC
  UPDATED_AT_DESC
  UPDATED_AT_ASC
  VALUE_ASC
  VALUE_DESC
  ORDER_ASC
  ORDER_DESC
  ANCESTOR_BOX_ID
  ANCESTOR_BOX_ID_DESC
  MIN_LEVEL_REQUIRED
  MIN_LEVEL_REQUIRED_DESC
  TOTAL_BOX_OPENINGS
  TOTAL_BOX_OPENINGS_DESC
  TOTAL_SPENT
  TOTAL_SPENT_DESC
  COST_ASC
  COST_DESC
  ANCESTOR_TOTAL_BOX_OPENINGS
  ANCESTOR_TOTAL_BOX_OPENINGS_DESC
  ANCESTOR_TOTAL_SPENT
  ANCESTOR_TOTAL_SPENT_DESC
}

enum BoxType {
  OFFICIAL
  CUSTOM
}

type CalendarEntry implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  calendarId: ID!
  calendar: Calendar!
  userId: ID!
  user: User!
  rewardCount: Int!
}

type CalendarEntryConnection {
  pageInfo: PageInfo!
  edges: [CalendarEntryEdge]
  total: Int
}

type CalendarEntryEdge {
  node: CalendarEntry
  cursor: String!
}

type CreateCalendarEntryPayload {
  calendarEntry: CalendarEntry!
}

type CreateCalendarEntrySubscriptionPayload {
  calendarEntry: CalendarEntry!
}

input CreateCalendarEntryInput {
  calendarId: ID!
  recaptcha: String!
  visualRecaptcha: String
}

enum CalendarEntryOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type CalendarReward {
  chance: Float!
  lastDeposit: Duration
  minAmount: Int!
  maxAmount: Int!
  level: Int
}

type Calendar implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  creatorId: ID!
  creator: User!
  dailyOpenCount: Int!
  name: String!
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  entries: CalendarEntryConnection!
  rewards: [CalendarReward!]!
}

type CalendarConnection {
  pageInfo: PageInfo!
  edges: [CalendarEdge]
  total: Int
}

type CalendarEdge {
  node: Calendar
  cursor: String!
}

type CreateCalendarPayload {
  calendar: Calendar!
}

type UpdateCalendarPayload {
  calendar: Calendar!
}

type DeleteCalendarPayload {
  calendar: Calendar!
}

type CreateCalendarSubscriptionPayload {
  calendar: Calendar!
}

type DeleteCalendarSubscriptionPayload {
  calendar: Calendar!
}

type UpdateCalendarSubscriptionPayload {
  calendar: Calendar!
}

input CalendarRewardInput {
  chance: Float!
  lastDeposit: Duration
  maxAmount: Int!
  minAmount: Int!
  level: Int
}

input CreateCalendarInput {
  dailyOpenCount: Int
  endAt: SequelizeDate!
  name: String!
  rewards: [CalendarRewardInput!]!
  startAt: SequelizeDate!
}

input DeleteCalendarInput {
  id: ID!
}

input UpdateCalendarInput {
  dailyOpenCount: Int
  endAt: SequelizeDate
  id: ID!
  name: String
  rewards: [CalendarRewardInput!]
  startAt: SequelizeDate
}

enum CalendarOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type Country {
  dialCode: String
  code: String
  name: String
  flag: String
  currency: String
  enabled: Boolean
  european: Boolean
  minimumAge: Int
}

type CrashBetItem implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  crashBetId: ID!
  crashBet: CrashBet
  itemVariantId: ID!
  itemVariant: ItemVariant
  userItemId: ID
  userItem: UserItem
}

type CrashBetItemConnection {
  pageInfo: PageInfo!
  edges: [CrashBetItemEdge]
  total: Int
}

type CrashBetItemEdge {
  node: CrashBetItem
  cursor: String!
}

enum CrashBetItemOrderBy {
  ID
  ID_DESC
}

type CrashBet implements Node {
  id: ID!
  tick: Int
  maxTick: Int
  amount: Float
  totalBet: Float
  totalWinAmount: Float
  remainderWinAmount: Float
  mode: CrashBetMode!
  currency: String!
  desiredItemVariantId: ID
  desiredItemVariant: ItemVariant
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID!
  user: User!
  userItemId: ID
  userItem: UserItem
  gameId: ID
  game: CrashGame
  items(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [CrashBetItemOrderBy]
  ): CrashBetItemConnection
  ticketsWon: Int!
}

type CrashBetConnection {
  pageInfo: PageInfo!
  edges: [CrashBetEdge]
  total: Int
}

type CrashBetEdge {
  node: CrashBet
  cursor: String!
}

type CrashBetItemVariantConnection {
  pageInfo: PageInfo!
  edges: [CrashBetItemVariantEdge]
  total: Int
}

type CrashBetItemVariantEdge {
  node: ItemVariant
  cursor: String!
}

type CreateCrashBetPayload {
  crashBet: CrashBet
}

type ExitCrashPayload {
  crashBet: CrashBet
}

type CreateCrashBetSubscriptionPayload {
  crashBet: CrashBet!
}

type UpdateCrashBetSubscriptionPayload {
  crashBet: CrashBet!
}

type CrashBetStats {
  commonAmounts: [Float!]!
  commonMaxTicks: [Int!]!
}

input CreateCrashBetInput {
  amount: Float!
  desiredItemVariantId: ID
  gameId: ID
  maxTick: Int
  mode: CrashBetMode
  userItemIds: [ID]!
}

input ExitCrashInput {
  betId: ID!
  secret: String
}

enum CrashBetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CrashBetMode {
  COINS_ONLY
  ITEMS_AND_COINS
}

type CrashGame implements Node {
  id: ID!
  status: CrashGameStatus!
  seed: String
  roll: Int
  startedAt: SequelizeDate!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  scheduledAt: SequelizeDate
  totalBetCount: Float
  totalUserCount: Float
  totalBet: Float
  totalPayout: Float
  currency: String!
  bets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): CrashBetConnection
}

type CrashGameConnection {
  pageInfo: PageInfo!
  edges: [CrashGameEdge]
  total: Int
}

type CrashGameEdge {
  node: CrashGame
  cursor: String!
}

type CreateCrashGameSubscriptionPayload {
  crashGame: CrashGame!
}

type UpdateCrashGameSubscriptionPayload {
  crashGame: CrashGame!
}

enum CrashGameOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum CrashGameStatus {
  CREATED
  STARTED
  FINISHED
}

type CronJob implements Node {
  id: ID!
  name: String!
  description: String!
  schedule: String!
  timeZone: String!
  userUpdateTime: SequelizeDate
  state: SchedulerState!
  status: JSON
  scheduleTime: SequelizeDate
  lastAttemptTime: SequelizeDate
  retryConfig: JSON
  attemptDeadline: SequelizeDate
  pubsubTarget: JSON
  appEngineHttpTarget: JSON
  httpTarget: JSON
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type CronJobConnection {
  pageInfo: PageInfo!
  edges: [CronJobEdge]
  total: Int
}

type CronJobEdge {
  node: CronJob
  cursor: String!
}

type CreateCronJobPayload {
  cronJob: CronJob
}

type DeleteCronJobPayload {
  cronJob: CronJob
}

type PauseCronJobPayload {
  cronJob: CronJob
}

type ResumeCronJobPayload {
  cronJob: CronJob
}

input CreateCronJobInput {
  name: String!
  appEngineHttpTarget: SchedulerAppEngineHttpTargetInput
  description: String!
  httpTarget: SchedulerHttpTargetInput
  pubsubTarget: SchedulerPubsubTargetInput
  retryConfig: SchedulerRetryConfigInput
  schedule: String!
  timeZone: String!
}

input SchedulerDurationInput {
  seconds: Int
  nanos: Int
}

input SchedulerRetryConfigInput {
  retryCount: Int
  maxRetryDuration: SchedulerDurationInput
  minBackoffDuration: SchedulerDurationInput
  maxBackoffDuration: SchedulerDurationInput
  maxDoublings: Int
}

input SchedulerHttpTargetInput {
  uri: String
  httpMethod: SchedulerHttpMethod
  headers: JSON
  body: String
}

input SchedulerPubsubTargetInput {
  topicName: String
  data: String
  attributes: JSON
}

input SchedulerAppEngineHttpTargetInput {
  httpMethod: SchedulerHttpMethod
  appEngineRouting: SchedulerAppEngineRoutingInput
  relativeUri: String
  headers: JSON
  body: String
}

input SchedulerAppEngineRoutingInput {
  service: String
  version: String
  instance: String
  host: String
}

input DeleteCronJobInput {
  name: String!
}

input PauseCronJobInput {
  name: String!
}

input ResumeCronJobInput {
  name: String!
}

enum SchedulerState {
  ENABLED
  DISABLED
  PAUSED
  STATE_UNSPECIFIED
  UPDATE_FAILED
}

enum CronJobOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum SchedulerHttpMethod {
  HTTP_METHOD_UNSPECIFIED
  POST
  GET
  HEAD
  PUT
  DELETE
  PATCH
  OPTIONS
}

type Dashboard {
  transactions(
    currency: String
    status: TransactionStatus
    type: TransactionType
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): TransactionStats
  registrations(minDate: SequelizeDate, maxDate: SequelizeDate): Float
  games(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
  ): GameStats
  gameJackpots(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): GameJackpotStats
  jackpotWinningTickets(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): JackpotWinningTicketsStats
  crashGames(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
  ): CrashGameStats
  boxOpenings(
    currency: String
    hasPvpGame: Boolean
    minDate: SequelizeDate
    maxDate: SequelizeDate
    minValue: Float
    maxValue: Float
    maxLevel: Int
    minLevel: Int
    type: BoxType
    includeExcluded: Boolean
    walletType: [WalletType!]
  ): BoxOpeningStats
  diceBets(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
    gameTypes: [DiceGameType!]
  ): DiceBetStats
  matchBettingSlips(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
  ): MatchBettingSlipStats
  pvpGames(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
    types: [PvpGameType!]
  ): PvpGameStats
  pvpBotGames(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    includeExcluded: Boolean
    types: [PvpGameType!]
  ): PvpGameStats
  promoRedemptions(
    currency: String
    type: PromoCodeType
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): PromoCodeRedemptionStats
  giveaways(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    walletType: [WalletType!]
  ): GiveawayStats
  exchanges(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): ExchangeStats
  orders(
    currency: String
    creatorId: ID
    userId: ID
    minDate: SequelizeDate
    maxDate: SequelizeDate
    retailer: Retailer
  ): OrderStats
  walletChanges(
    currency: String
    minDate: SequelizeDate
    maxDate: SequelizeDate
    userId: ID
    type: [WalletChangeType]
    excludeStaff: Boolean
  ): [WalletChangeStats!]!
  totalWalletValue(currency: String, name: WalletType): WalletStats!
  userItems(
    currency: String
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    requestedAtMinDate: SequelizeDate
    requestedAtMaxDate: SequelizeDate
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    status: [UserItemStatus!]
    userId: ID
    creatorId: ID
    retailer: Retailer
  ): UserItemStats
  userProgressChanges(
    minDate: SequelizeDate
    maxDate: SequelizeDate
    userId: ID
    source: [UserProgressSource]
    excludeStaff: Boolean
  ): [UserProgressChangeStats!]!
  trades(
    bySupplier: Boolean
    currency: String
    status: [TradeStatus!]
    deposits: Boolean
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    userId: ID
  ): TradeStats
  waxPeerTrades(
    currency: String
    status: [WaxPeerTradeStatus!]
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    userId: ID
  ): WaxPeerTradeStats
  zbtTrades(
    currency: String
    status: [ZbtTradeStatus!]
    createdAtMinDate: SequelizeDate
    createdAtMaxDate: SequelizeDate
    updatedAtMinDate: SequelizeDate
    updatedAtMaxDate: SequelizeDate
    userId: ID
  ): ZbtTradeStats
}

type WalletStats {
  currency: String!
  totalValue: Float!
}

type WalletChangeStats {
  currency: String
  type: WalletChangeType
  totalValueChange: Float
}

type TransactionStats {
  provider: [TransactionStatProvider]
}

type TransactionStatProvider {
  count: Int
  totalAmount: Float
  provider: PaymentProvider
  currency: String!
}

type ExchangeStats {
  count: Int
  userItemsValue: Float
  itemsValue: Float
  remainder: Float
  profit: Float
  currency: String!
}

type GameStats {
  count: Int
  totalBetCount: Int
  totalUserCount: Int
  totalBet: Float
  totalPayout: Float
  currency: String!
}

type GameJackpotStats {
  count: Int
  totalInitialValue: Float
  totalValue: Float
  totalWageredValue: Float
  currency: String!
}

type JackpotWinningTicketsStats {
  count: Int
  totalUserItemAcquiredValue: Float
  currency: String!
}

type DiceBetStats {
  count: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  currency: String!
}

type OrderStats {
  count: Int
  cost: Float
  deliveryCost: Float
  currency: String!
}

type CrashGameStats {
  count: Int
  totalBetCount: Int
  totalUserCount: Int
  totalBet: Float
  totalPayout: Float
  currency: String!
}

type BoxOpeningStats {
  count: Int
  totalBoxValue: Float
  totalItemValue: Float
  totalProfit: Float
  currency: String!
}

type PromoCodeRedemptionStats {
  count: Float
  balance: Float
  currency: String!
}

type GiveawayStats {
  count: Int!
  totalRewardAmount: Float!
  currency: String!
}

type MatchBettingSlipStats {
  count: Int
  totalBet: Float
  totalPayout: Float
  currency: String!
}

type PvpGameStats {
  count: Int
  totalBetCount: Int
  totalBet: Float
  totalHouseEdge: Float
  totalPayout: Float
  currency: String!
}

type UserItemStats {
  count: Int
  acquiredValue: Float
  consumedValue: Float
  currentValue: Float
  currency: String!
}

type UserProgressChangeStats {
  source: UserProgressSource
  totalValueChange: Int
}

type TradeStats {
  count: Int
  currentValue: Float
  currency: String!
}

type WaxPeerTradeStats {
  count: Int
  value: Float
  valuePaid: Float
  currency: String!
}

type ZbtTradeStats {
  count: Int
  value: Float
  valuePaid: Float
  currency: String!
}

type DiceBetItem {
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type DiceBet implements Node {
  id: ID!
  userId: ID!
  user: User!
  rollId: ID!
  roll: Roll!
  amount: Float!
  currency: String!
  totalBet: Float!
  totalRemainderPayout: Float!
  totalPayout: Float!
  profit: Float!
  choice: DiceBetChoice!
  won: Boolean!
  chance: Float!
  houseEdgePercent: Float!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  betItems: [DiceBetItem!]
  ticketsWon: Int!
  gameType: DiceGameType!
  wonUserItemId: ID
  wonUserItem: UserItem
  desiredItemVariantId: ID
  desiredItemVariant: ItemVariant
}

type DiceBetConnection {
  pageInfo: PageInfo!
  edges: [DiceBetEdge]
  total: Int
}

type DiceBetEdge {
  node: DiceBet
  cursor: String!
}

type CreateDiceBetsPayload {
  diceBets: [DiceBet]
}

type CreateDiceBetsSubscriptionPayload {
  diceBets: [DiceBet!]
}

input CreateDiceBetsInput {
  amount: Float!
  chance: Float
  choice: DiceBetChoice!
  desiredItemVariantId: ID
  mode: DiceBetMode!
  rollsPerClick: Int!
  userItemIds: [ID!]!
}

enum DiceBetOrderBy {
  CHANCE_DESC
  CHANCE
  ID_DESC
  ID
  PROFIT_DESC
  PROFIT
  TOTAL_BET_DESC
  TOTAL_BET
}

enum DiceBetMode {
  ANIMATION
  AUTO
  BATCH
  MANUAL
}

enum DiceBetChoice {
  OVER
  UNDER
}

enum DiceGameType {
  DICE
  UPGRADE
}

type DigitalCode implements Node {
  id: ID!
  itemVariantIds: [ID!]!
  itemVariants: [ItemVariant!]!
  code: String
  userId: ID
  user: User
  userItemId: ID
  userItem: UserItem
  consumedAt: SequelizeDate
  creatorId: ID
  creator: User
  deletorId: ID
  deletor: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type DigitalCodeConnection {
  pageInfo: PageInfo!
  edges: [DigitalCodeEdge]
  total: Int
}

type DigitalCodeEdge {
  node: DigitalCode
  cursor: String!
}

type CreateDigitalCodePayload {
  ids: [ID!]!
}

type DeleteDigitalCodePayload {
  digitalCode: DigitalCode!
}

type CreateDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

type UpdateDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

type DeleteDigitalCodeSubscriptionPayload {
  digitalCode: DigitalCode!
}

input CreateDigitalCodesInput {
  codes: [String!]!
  itemVariantIds: [ID!]!
}

enum DigitalCodeOrderBy {
  ID
  ID_DESC
}

type Document implements Node {
  id: ID!
  verified: Boolean
  type: DocumentType
  userId: ID!
  user: User!
  assetId: ID
  asset: Asset
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate!
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]
  total: Int
}

type DocumentEdge {
  node: Document
  cursor: String!
}

type CreateDocumentPayload {
  document: Document
}

type UpdateDocumentPayload {
  document: Document
}

type DeleteDocumentPayload {
  document: Document
}

type CreateDocumentSubscriptionPayload {
  document: Document!
}

type DeleteDocumentSubscriptionPayload {
  document: Document!
}

input CreateDocumentInput {
  userId: ID!
  type: DocumentType
  upload: [Upload!]
}

input UpdateDocumentInput {
  id: ID!
  type: DocumentType
  verified: Boolean
  upload: [Upload!]
}

input DeleteDocumentInput {
  id: ID!
}

enum DocumentOrderBy {
  ID
  ID_DESC
}

enum DocumentType {
  IDENTITY
  RESIDENCE
}

# ISO 8601 Durations define the amount of intervening time in a time interval and are represented by the format P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W
scalar Duration

type EbaySearch {
  searchResults: [EbayItem]
  pagination: EbayPagination
}

type EbayItem {
  itemId: String
  title: String
  globalId: String
  primaryCategory: EbayItemCategory
  galleryUrl: String
  viewItemUrl: String
  postalCode: String
  location: String
  country: String
  condition: String
  currency: String
  price: Float
  shippingInfo: EbayShipping
}

type EbayItemCategory {
  categoryId: String
  categoryName: String
}

type EbayShipping {
  shippingServiceCost: Float
  shippingType: [String]
  shipToLocations: [String]
}

type EbayPagination {
  pageNumber: Int
  entriesPerPage: Int
  totalPages: Int
  totalEntries: Int
}

type EmailWaitingList implements Node {
  id: ID!
  email: String!
  status: EmailWaitingListStatus!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type EmailWaitingListConnection {
  pageInfo: PageInfo!
  edges: [EmailWaitingListEdge]
  total: Int
}

type EmailWaitingListEdge {
  node: EmailWaitingList
  cursor: String!
}

type EmailWaitingListPayload {
  email: String!
  status: EmailWaitingListStatus!
}

input EmailWaitingListInput {
  email: String!
}

enum EmailWaitingListOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum EmailWaitingListStatus {
  INVITED
  WAITING
}

type CreateEmailPayload {
  emails: [String!]
  count: Int
  email: String
  title: String!
}

input CreateEmailInput {
  userId: ID
  userIds: [ID!]
  title: String!
  message: String!
}

type ExchangeRate {
  currency: String
  rate: Float
}

type ExchangeRates {
  updatedAt: SequelizeDate
  currency: String
  rates: [ExchangeRate]
}

type Exchange implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userItemsValue: Float!
  itemsValue: Float!
  remainder: Float!
  currency: String!
  profit: Float!
  userId: ID
  user: User
  itemVariants(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): ItemVariantConnection!
  userItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): UserItemConnection!
  newUserItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): UserItemConnection!
}

type ExchangeConnection {
  pageInfo: PageInfo!
  edges: [ExchangeEdge]
  total: Int
}

type ExchangeEdge {
  node: Exchange
  cursor: String!
}

type CreateExchangePayload {
  exchange: Exchange
}

input CreateExchangeInput {
  userItemIds: [ID!]!
  itemVariantIds: [ID!]!
}

enum ExchangeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type ForgotPasswordPayload {
  success: Boolean!
}

input ForgotPasswordInput {
  email: String!
  redirectUri: String!
  recaptcha: String!
  visualRecaptcha: String
}

type GameJackpotWinner implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  gameJackpotId: ID!
  gameJackpot: GameJackpot!
  amount: Float!
  currency: String!
  userId: ID!
  user: User!
}

type GameJackpotWinnerConnection {
  pageInfo: PageInfo!
  edges: [GameJackpotWinnerEdge]
  total: Int
}

type GameJackpotWinnerEdge {
  node: GameJackpotWinner
  cursor: String!
}

enum GameJackpotWinnerOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
}

type GameJackpot implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  completedAt: SequelizeDate
  gameId: ID
  game: Game
  initialValue: Float!
  value: Float!
  winners(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [GameJackpotWinnerOrderBy]
  ): GameJackpotWinnerConnection!
  totalValue: Float!
  currency: String!
  consecutiveCount: Int!
  wager: Float!
  payoutStructure: [GameJackpotPayoutStructure!]!
}

type GameJackpotConnection {
  pageInfo: PageInfo!
  edges: [GameJackpotEdge]
  total: Int
}

type GameJackpotEdge {
  node: GameJackpot
  cursor: String!
}

type UpdateGameJackpotPayload {
  gameJackpot: GameJackpot!
}

type CreateGameJackpotSubscriptionPayload {
  gameJackpot: GameJackpot!
}

type UpdateGameJackpotSubscriptionPayload {
  gameJackpot: GameJackpot!
}

type GameJackpotPayoutStructure {
  payoutPercent: Float!
}

enum GameJackpotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

type GameMessage {
  body: String!
  gameId: ID!
  userId: ID!
}

type PvpGameMessage {
  body: String!
  pvpGameId: ID!
  userId: ID!
}

type CreateGameMessagePayload {
  gameMessage: GameMessage!
}

type CreateGameMessageSubscriptionPayload {
  gameMessage: GameMessage!
}

type CreatePvpGameMessagePayload {
  pvpGameMessage: PvpGameMessage!
}

type CreatePvpGameMessageSubscriptionPayload {
  pvpGameMessage: PvpGameMessage!
}

input CreateGameMessageInput {
  gameId: ID!
  body: String!
}

input CreatePvpGameMessageInput {
  pvpGameId: ID!
  body: String!
}

type Game implements Node {
  id: ID!
  rollId: ID
  roll: Roll
  maxPlayers: Int
  scheduledAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  status: GameStatus!
  totalBetCount: Float
  totalUserCount: Float
  totalBet: Float
  totalPayout: Float
  currency: String!
  bets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): BetConnection!
  rollValue: Int
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]
  total: Int
}

type GameEdge {
  node: Game
  cursor: String!
}

type RefreshCachedLatestGamesPayload {
  success: Boolean!
}

type VerifyGamePayload {
  success: Boolean!
}

type CreateGameSubscriptionPayload {
  game: Game!
}

type RefreshCachedLatestGamesSubscriptionPayload {
  success: Boolean
}

type UpdateGameSubscriptionPayload {
  game: Game!
}

input RefreshCachedLatestGamesInput {
  secret: String
}

input VerifyGameInput {
  gameId: ID!
  secret: String
}

enum GameOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum GameStatus {
  CREATED
  STARTED
  FINISHED
}

type GemstoneBoostActivation {
  id: ID!
  gemstoneBoostId: ID!
  gemstoneBoost: GemstoneBoost!
  userId: ID
  user: User
  teamId: ID
  team: Team
  amountMultiplier: Float
  activatedByAction: GemstoneBoostActivatedByAction!
  activatedByItemVariantId: ID
  activatedByItemVariant: ItemVariant
  activatedByUserId: ID
  activatedByUser: User
  startAt: SequelizeDate
  endAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneBoostActivationConnection {
  pageInfo: PageInfo!
  edges: [GemstoneBoostActivationEdge]
  total: Int
}

type GemstoneBoostActivationEdge {
  node: GemstoneBoostActivation
  cursor: String!
}

type CreateGemstoneBoostActivationPayload {
  gemstoneBoostActivation: GemstoneBoostActivation
}

enum GemstoneBoostActivatedByAction {
  ITEM_VARIANT_UNBOXING
  TOTAL_POINTS
}

enum GemstoneBoostActivationOrderBy {
  ID
  ID_DESC
}

type GemstoneBoost {
  id: ID!
  startAt: SequelizeDate!
  endAt: SequelizeDate!
  activationPeriod: Int!
  status: GemstoneBoostStatus!
  currency: String!
  walletType: WalletType!
  amountMultiplier: Float
  userGemstoneThreshold: Float
  teamGemstoneThreshold: Float
  teamBoostActivatedByItemVariantId: ID
  teamBoostActivatedByItemVariant: ItemVariant
  userBoostActivatedByItemVariantId: ID
  userBoostActivatedByItemVariant: ItemVariant
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneBoostTeamInfo {
  currentPoints: Float!
  pointThreshold: Int
  team: Team!
  teamId: ID!
  totalActivationsByItemVariant: Int!
  totalActivationsByPoints: Int!
  totalPoints: Float!
}

type GemstoneBoostUserInfo {
  currentPoints: Float!
  pointThreshold: Int
  totalActivationsByItemVariant: Int!
  totalActivationsByPoints: Int!
  totalPoints: Float!
  user: User!
  userId: ID!
}

type GemstoneBoostInfo {
  gemstoneBoost: GemstoneBoost
  teamsInfo: [GemstoneBoostTeamInfo!]!
  userInfo: GemstoneBoostUserInfo
}

type UpdateGemstoneBoostSubscriptionPayload {
  gemstoneBoostInfo: GemstoneBoostInfo!
}

type CreateGemstoneBoostPayload {
  gemstoneBoost: GemstoneBoost
}

type UpdateGemstoneBoostPayload {
  gemstoneBoost: GemstoneBoost
}

input CreateGemstoneBoostInput {
  activationPeriod: Int!
  amountMultiplier: Float!
  currency: String!
  endAt: SequelizeDate!
  startAt: SequelizeDate!
  status: GemstoneBoostStatus!
  teamGemstoneThreshold: Int
  walletType: WalletType
}

input UpdateGemstoneBoostInput {
  endAt: SequelizeDate
  gemstoneBoostId: ID!
  secret: String
  status: GemstoneBoostStatus
}

input ActivateBoostInput {
  userId: ID
  teamId: ID
  walletType: WalletType!
}

enum GemstoneBoostStatus {
  ENABLED
  DISABLED
}

type GemstoneGame implements Node {
  id: ID!
  betAmount: Float
  chance: Float
  currency: String
  walletType: WalletType
  winAmount: Float
  user: User!
  userId: ID!
  gemstoneBoostActivationId: ID
  gemstoneBoostActivation: GemstoneBoostActivation
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
}

type GemstoneGameConnection {
  pageInfo: PageInfo!
  edges: [GemstoneGameEdge]
  total: Int
}

type GemstoneGameEdge {
  node: GemstoneGame
  cursor: String!
}

type WinGemstoneSubscription {
  gemstone: GemstoneGame
}

type GemstoneGameLeaderboardBox {
  boxId: ID
  box: Box
  winAmount: Float
}

type GemstoneGameLeaderboard {
  board: [GemstoneGameLeaderboardNode]
  myItem: GemstoneGameLeaderboardNode
}

type GemstoneGameLeaderboardNode {
  boxes: [GemstoneGameLeaderboardBox]
  luck: Float @deprecated(reason: "Removed as too expensive")
  position: Int
  userId: ID
  user: User
  spent: Float
  winAmount: Float
}

enum GemstoneGameOrderBy {
  BET_AMOUNT_DESC
  BET_AMOUNT
  CREATED_AT_DESC
  CREATED_AT
  ID_DESC
  ID
  WIN_AMOUNT_DESC
  WIN_AMOUNT
}

type GeoTrack implements Node {
  id: ID!
  userId: ID!
  user: User!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  ip: String
  country: String
}

type GeoTrackSummary {
  countries: [GeoTrackSummaryItem!]!
  ips: [GeoTrackSummaryItem!]!
  totalCountries: [GeoTrackSummaryItem!]!
  totalIps: [GeoTrackSummaryItem!]!
}

type GeoTrackUserSummary {
  countries: [String!]!
  ips: [String!]!
  totalCountries: [GeoTrackSummaryItem!]!
  totalIps: [GeoTrackSummaryItem!]!
}

type GeoTrackSummaryItem {
  id: String!
  score: Int!
}

type GeoTrackConnection {
  pageInfo: PageInfo!
  edges: [GeoTrackEdge]
  total: Int
}

type GeoTrackEdge {
  node: GeoTrack
  cursor: String!
}

enum GeoTrackOrderBy {
  COUNTRY
  COUNTRY_DESC
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type Giveaway implements Node {
  id: ID!
  name: String
  status: GiveawayStatus!
  startAt: SequelizeDate
  endAt: SequelizeDate
  completedAt: SequelizeDate
  rewardAmount: Int!
  winnersAmount: Int!
  currency: String!
  totalEntries: Int!
  walletType: WalletType!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  entryRequirements: GiveawayEntryRequirements
}

type GiveawayConnection {
  pageInfo: PageInfo!
  edges: [GiveawayEdge]
  total: Int
}

type GiveawayEdge {
  node: Giveaway
  cursor: String!
}

type UpdateGiveawayPayload {
  giveaway: Giveaway
}

type CreateGiveawayPayload {
  giveaway: Giveaway
}

type AnnounceGiveawayPayload {
  message: Message
}

type GiveawayEntryRequirements {
  userLevel: Int
  userLastDepositAt: SequelizeDate
  userLastDepositAtIn: Duration
}

input CreateGiveawayInput {
  announceAtDates: [SequelizeDate!]
  currency: String!
  endAt: SequelizeDate
  endIn: Duration
  entryRequirements: GiveawayEntryRequirementsInput
  name: String
  rewardAmount: Float!
  secret: String
  startAt: SequelizeDate
  startIn: Duration
  walletType: WalletType!
  winnersAmount: Int!
}

input JoinGiveawayInput {
  giveawayId: ID!
  recaptcha: String!
  visualRecaptcha: String
}

input UpdateGiveawayInput {
  secret: String
  giveawayId: ID!
  status: GiveawayStatus!
}

input AnnounceGiveawayInput {
  secret: String
  giveawayId: ID!
}

input GiveawayEntryRequirementsInput {
  userLevel: Int
  userLastDepositAt: SequelizeDate
  userLastDepositAtIn: Duration
}

enum GiveawayStatus {
  CREATED
  COMPLETED
  ENDED
  STARTED
}

enum GiveawayOrderBy {
  COMPLETED_AT
  COMPLETED_AT_DESC
  CREATED_AT
  CREATED_AT_DESC
  END_AT
  END_AT_DESC
  ID
  ID_DESC
  START_AT
  START_AT_DESC
}

type InviteCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  deletedAt: SequelizeDate
  updatedAt: SequelizeDate!
  code: String
  redeemCount: Int
  increasedInviteCount: Int
  userId: ID
  user: User
}

type InviteCodeConnection {
  pageInfo: PageInfo!
  edges: [InviteCodeEdge]!
  total: Int
}

type InviteCodeEdge {
  node: InviteCode
  cursor: String!
}

type CreateInviteCodePayload {
  inviteCode: InviteCode!
}

type UpdateInviteCodePayload {
  inviteCode: InviteCode!
}

input CreateInviteCodeInput {
  code: String!
  userId: ID
}

input UpdateInviteCodeInput {
  code: String
  increaseInviteCountBy: Int
  inviteCodeId: ID!
}

enum InviteCodeOrderBy {
  ID
  ID_DESC
}

type ItemCategory {
  id: ID!
  name: String!
  order: Int
  shippingInfo: String
  items(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [ItemOrderBy]
    name: String
    minValue: Float
    maxValue: Float
    obtainable: Boolean
    usable: Boolean
    withdrawable: Boolean
    categoryId: ID
  ): ItemConnection!
}

type ItemCategoryConnection {
  pageInfo: PageInfo!
  edges: [ItemCategoryEdge]
}

type ItemCategoryEdge {
  node: ItemCategory
  cursor: String!
}

type CreateCategoryPayload {
  itemCategory: ItemCategory
}

type UpdateCategoryPayload {
  itemCategory: ItemCategory
}

type CreateItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

type UpdateItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

type DeleteItemCategorySubscriptionPayload {
  itemCategory: ItemCategory!
}

input CreateItemCategoryInput {
  name: String!
  shippingInfo: String!
  defaultExchangeRate: Float!
  defaultMarkup: Float!
}

input UpdateItemCategoryInput {
  id: ID!
  name: String
  order: Int
  shippingInfo: String
  defaultExchangeRate: Float
  defaultMarkup: Float
}

input DeleteItemCategoryInput {
  id: ID!
}

enum ItemCategoryOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  ORDER
  ORDER_DESC
}

type ItemVariant {
  id: ID!
  name: String
  value: Float!
  displayValue: Float!
  markup: Float!
  currency: String!
  itemId: ID!
  color: String
  size: String
  iconUrl: String!
  purchaseUrl: String
  obtainable: Boolean!
  usable: Boolean!
  withdrawable: Boolean!
  depositable: Boolean!
  purchasable: ItemPurchasable!
  categoryId: ID
  category: ItemCategory
  type: ItemType
  exchangeRate: Float!
  shippingCost: Float
  shippingInfo: String
  description: String
  brand: String
  rarity: String
  retailer: Retailer
  marketId: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  item: Item!
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  availableAssets: [AvailableAsset!]
  totalRequested: Int
  totalAvailable: Int
  totalFulfilled: Int
  totalUnfulfilled: Int
  estimatedDeliveryInHours: String
}

type InventoryItemVariants {
  steamItems: [ItemVariant!]!
  activeTradeItems: [ItemVariant!]!
}

type Inventory {
  activeTradeItems: [ItemVariant!]!
  steamItems: [InventoryItem!]!
}

type InventoryItem {
  cacheExpiration: String
  itemVariant: ItemVariant!
  tradable: Boolean!
}

type ItemVariantConnection {
  pageInfo: PageInfo!
  edges: [ItemVariantEdge]
  total: Int
}

type ItemVariantEdge {
  node: ItemVariant
  cursor: String!
}

type CreateItemVariantPayload {
  itemVariant: ItemVariant
}

type UpdateItemVariantPayload {
  itemVariant: ItemVariant
}

type DeleteItemVariantPayload {
  itemVariant: ItemVariant
}

type CreateItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type UpdateItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type DeleteItemVariantSubscriptionPayload {
  itemVariant: ItemVariant!
}

type UpdateItemVariantsPayload {
  itemVariants: [ItemVariant]!
  total: Int!
}

type AddUpdateItemVariantsTaskInputPayload {
  success: Boolean
}

input CreateItemVariantInput {
  name: String
  value: Float!
  displayValue: Float!
  markup: Float!
  itemId: ID!
  iconUrl: String!
  purchaseUrl: String
  exchangeRate: Float!
  shippingCost: Float!
  shippingInfo: String
  color: String
  size: String
  description: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  brand: String
  rarity: String
  retailer: Retailer
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  purchasable: ItemPurchasable
  type: ItemType
}

input UpdateItemVariantInput {
  itemVariantId: ID!
  name: String
  value: Float
  displayValue: Float
  markup: Float
  color: String
  size: String
  iconUrl: String
  purchaseUrl: String
  description: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  exchangeRate: Float
  shippingCost: Float
  shippingInfo: String
  brand: String
  rarity: String
  retailer: Retailer
  releasedAt: SequelizeDate
  externalId: String
  approvalStrategy: ItemVariantApprovalStrategy
  purchasable: ItemPurchasable
}

input DeleteItemVariantInput {
  id: ID!
}

enum ItemVariantOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DISPLAY_VALUE
  DISPLAY_VALUE_DESC
  RELEASED_AT
  RELEASED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
  AVAILABLE_ASSETS
  AVAILABLE_ASSETS_DESC
  HAS_AVAILABLE_ASSETS
  HAS_AVAILABLE_ASSETS_DESC
  TOTAL_REQUESTED
  TOTAL_REQUESTED_DESC
}

enum ItemVariantApprovalStrategy {
  AUTO
  MANUAL
}

enum ItemPurchasable {
  NOT_PURCHASABLE
  PURCHASABLE
  PURCHASABLE_WHEN_IN_STOCK
}

type Item implements Node {
  id: ID!
  name: String
  value: Float!
  currency: String!
  minValue: Float!
  maxValue: Float!
  minDisplayValue: Float!
  maxDisplayValue: Float!
  displayValue: Float
  exchangeRate: Float!
  markup: Float!
  shippingCost: Float
  iconUrl: String
  purchaseUrl: String
  categoryId: ID
  category: ItemCategory
  type: ItemType
  obtainable: Boolean!
  usable: Boolean!
  withdrawable: Boolean!
  description: String
  brand: String
  shippingInfo: String
  marketId: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  tags: [Tag!]
  users: [User]
  itemVariants: [ItemVariant]
  releasedAt: SequelizeDate
  externalId: String
  availableAssets: [AvailableAsset]
  minRarity: String
  maxRarity: String
  valueUpdatedAt: SequelizeDate
  valueRecentlyUpdated: Boolean!
  estimatedDeliveryInHours: String
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]
  total: Int
}

type ItemEdge {
  node: Item
  cursor: String!
}

type CreateItemPayload {
  item: Item
}

type CreateItemsPayload {
  items: [Item!]!
  total: Int!
}

type CloneItemPayload {
  item: Item
}

type UpdateItemPayload {
  item: Item
}

type CreateItemSubscriptionPayload {
  item: Item!
}

type UpdateItemSubscriptionPayload {
  item: Item!
}

type UpdateItemMarkupsPayload {
  success: Boolean
}

type UpdateItemValuesPayload {
  success: Boolean
}

type UpdateItemDisplayValuesPayload {
  success: Boolean
}

type UpdateItemExchangeRatesPayload {
  success: Boolean
}

type SyncItemPricesPayload {
  success: Boolean
}

type SyncNewItemsPayload {
  success: Boolean
}

type FlattenItemPayload {
  success: Boolean
}

input ItemTagInput {
  id: ID!
}

input CreateItemInput {
  name: String
  value: Float!
  displayValue: Float!
  exchangeRate: Float!
  markup: Float!
  shippingCost: Float!
  iconUrl: String!
  purchaseUrl: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  depositable: Boolean
  categoryId: ID
  marketId: ID!
  description: String!
  brand: String!
  shippingInfo: String!
  color: String
  size: String
  rarity: String
  releasedAt: SequelizeDate
  externalId: String
  tagIds: [ItemTagInput!]
  type: ItemType
}

input CloneItemInput {
  itemId: ID!
  targetMarketId: ID!
}

input UpdateItemInput {
  itemId: ID!
  name: String
  displayValue: Float
  exchangeRate: Float
  markup: Float
  shippingCost: Float
  iconUrl: String
  purchaseUrl: String
  obtainable: Boolean
  usable: Boolean
  withdrawable: Boolean
  categoryId: ID
  description: String
  brand: String
  shippingInfo: String
  releasedAt: SequelizeDate
  externalId: String
  tagIds: [ItemTagInput!]
}

input UpdateItemMarkupsInput {
  marketId: ID!
  categoryId: ID
  markup: Float!
}

input UpdateItemValuesInput {
  marketId: ID!
  categoryId: ID
  multiply: Float!
}

input UpdateItemDisplayValuesInput {
  marketId: ID!
  categoryId: ID
  multiply: Float!
}

input UpdateItemExchangeRatesInput {
  marketId: ID!
  categoryId: ID
  exchangeRate: Float!
}

input SyncItemPricesInput {
  itemType: ItemType!
  limit: Int
  notify: Boolean
  secret: String
}

input SyncNewItemsInput {
  itemType: ItemType!
  limit: Int
  marketId: ID!
  notify: Boolean
  itemCategoryId: ID
  secret: String
}

input FlattenItemInput {
  itemId: ID
}

enum ItemOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DISPLAY_VALUE
  DISPLAY_VALUE_DESC
  RELEASED_AT
  RELEASED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
  AVAILABLE_ASSETS
  AVAILABLE_ASSETS_DESC
  VALUE_UPDATED_AT
  VALUE_UPDATED_AT_DESC
}

enum ItemType {
  CODE
  CSGO
  DOTA2
  H1Z1
  IRL
  OSRS
  PUBG
  RUST
  STEAM
}

type JackpotWinningTicket implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  jackpotId: ID!
  jackpot: Jackpot!
  ticketId: ID!
  ticket: Ticket!
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  userId: ID!
  user: User!
  position: Int
}

type JackpotWinningTicketConnection {
  pageInfo: PageInfo!
  edges: [JackpotWinningTicketEdge]
  total: Int
}

type JackpotWinningTicketEdge {
  node: JackpotWinningTicket
  cursor: String!
}

type JackpotWinningTicketSubscriptionPayload {
  jackpotWinningTicket: JackpotWinningTicket!
}

enum JackpotWinningTicketOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type GameWageringRequirement {
  gameType: GameType!
  wagerAmount: Float!
}

type Jackpot implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  scheduledAt: SequelizeDate
  gameWageringRequirements: [GameWageringRequirement!]!
  chance: Float!
  wager: Float!
  winnerCount: Int!
  initialValue: Float!
  value: Float!
  totalValue: Float!
  currency: String!
  won: Boolean!
  prizes: [ItemVariant]!
  payoutPercentages: [Float!]!
  jackpotWinningTickets: [JackpotWinningTicket]!
  totalTickets: Int!
  ticketsInfo: JackpotTicketsInfo
  userRequirements: UserRequirements
}

type JackpotConnection {
  pageInfo: PageInfo!
  edges: [JackpotEdge]
  total: Int
}

type JackpotEdge {
  node: Jackpot
  cursor: String!
}

type CreateJackpotPayload {
  jackpot: Jackpot
}

type UpdateJackpotPayload {
  jackpot: Jackpot
}

type PayoutJackpotPayload {
  jackpot: Jackpot
}

type CreateJackpotSubscriptionPayload {
  jackpot: Jackpot!
}

type UpdateJackpotSubscriptionPayload {
  jackpot: Jackpot!
}

type RecalculateJackpotPayload {
  jackpot: Jackpot!
}

type RecalculateJackpotTicketsPayload {
  total: Int!
}

type PayoutJackpotTicketPayload {
  jackpotWinningTicket: JackpotWinningTicket
}

type CompleteJackpotPayload {
  jackpot: Jackpot!
}

type JackpotTicketsInfo {
  minId: Int
  maxId: Int
}

type JackpotLeaderboardElement implements Node {
  id: ID!
  userId: ID!
  user: User!
  totalTickets: Int!
  totalValue: Float!
}

type JackpotLeaderboardEdge {
  node: JackpotLeaderboardElement
  cursor: String!
}

type JackpotLeaderboardConnection {
  pageInfo: PageInfo!
  edges: [JackpotLeaderboardEdge!]!
}

input GameWageringRequirementInput {
  gameType: GameType!
  wagerAmount: Float!
}

input UserRequirementsInput {
  teamMember: Boolean
}

input CreateJackpotInput {
  chance: Float!
  wager: Float!
  winnerCount: Int!
  initialValue: Int!
  payoutPercentages: [Float!]!
  gameWageringRequirements: [GameWageringRequirementInput!]!
  scheduledAt: SequelizeDate
  userRequirements: UserRequirementsInput
}

input UpdateJackpotInput {
  jackpotId: ID!
  chance: Float!
  wager: Float!
  winnerCount: Int!
  initialValue: Int!
  payoutPercentages: [Float!]!
  gameWageringRequirements: [GameWageringRequirementInput!]!
  scheduledAt: SequelizeDate
  userRequirements: UserRequirementsInput
}

input RecalculateJackpotInput {
  secret: String
}

input RecalculateJackpotTicketsInput {
  jackpotId: ID!
  secret: String
}

input PayoutTicketInput {
  position: Int
  sequentialNumber: Int
  teamId: ID
  ticketId: ID
}

input CompleteJackpotInput {
  jackpotId: ID!
}

enum JackpotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

type Asn {
  asn: String!
  domain: String!
  name: String!
  route: String!
  type: String!
}

type Carrier {
  name: String
  mcc: String
  mnc: String
}

type Currency {
  code: String
  name: String
  native: String
  plural: String
  symbol: String
}

type Language {
  name: String
  native: String
}

type Threat {
  isAnonymous: Boolean
  isBogon: Boolean
  isKnownAbuser: Boolean
  isKnownAttacker: Boolean
  isProxy: Boolean
  isThreat: Boolean
  isTor: Boolean
}

type TimeZone {
  abbr: String
  currentTime: String
  isDst: Boolean
  name: String
  offset: String
}

type Location {
  asn: Asn!
  callingCode: String
  carrier: Carrier
  city: String
  continentCode: String
  continentName: String
  count: String
  countryCode: String
  countryName: String
  currency: Currency
  emojiFlag: String
  emojiUnicode: String
  flag: String
  ip: String
  isEu: Boolean
  isBlocked: Boolean
  languages: [Language]
  latitude: String
  longitude: String
  organisation: String
  postal: String
  regionCode: String
  region: String
  success: Boolean!
  threat: Threat
  timeZone: TimeZone
}

type Market implements Node {
  id: ID!
  slug: String
  name: String
  currency: String!
  countries: [Country]
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
  usersCount: Int
  boxesCount: Int
  itemsCount: Int
  rouletteSummary(
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): MarketGameSummary
  crashSummary(
    minDate: SequelizeDate
    maxDate: SequelizeDate
  ): MarketGameSummary
}

type MarketConnection {
  pageInfo: PageInfo!
  edges: [MarketEdge]
  total: Int
}

type MarketEdge {
  node: Market
  cursor: String!
}

type MarketGameSummary {
  amount: Float
  players: Int
  profit: Float
}

type CreateMarketPayload {
  market: Market
}

type UpdateMarketPayload {
  market: Market
}

type DeleteMarketPayload {
  market: Market
}

type CloneMarketPayload {
  market: Market
}

input CreateUpdateMarketInput {
  name: String!
  slug: String!
  currency: String!
  countries: [String]!
}

enum MarketOrderBy {
  ID
  ID_DESC
  NAME
  CREATED_AT
  CREATED_AT_DESC
}

type MatchBettingGameMeta {
  mapName: String
}

type MatchBettingGame implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  beginAt: SequelizeDate
  complete: Boolean
  endAt: SequelizeDate
  draw: Boolean!
  finished: Boolean!
  forfeit: Boolean!
  length: Int
  match: MatchBettingMatch!
  matchId: ID!
  meta: MatchBettingGameMeta
  position: Int!
  status: MatchBettingGameStatus!
  videoGame: MatchBettingVideoGame!
  videoUrl: String
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  markets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    marketIds: [ID!]
    statuses: [MatchBettingMarketStatus!]
    types: [MatchBettingMarketType!]
  ): MatchBettingMarketConnection!
}

type MatchBettingGameConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingGameEdge]
  total: Int
}

type MatchBettingGameEdge {
  node: MatchBettingGame
  cursor: String!
}

type CreateMatchBettingGameSubscriptionPayload {
  matchBettingGame: MatchBettingGame!
}

type UpdateMatchBettingGameSubscriptionPayload {
  matchBettingGame: MatchBettingGame!
}

enum MatchBettingGameOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  POSITION
  POSITION_DESC
}

enum MatchBettingGameStatus {
  FINISHED
  NOT_PLAYED
  NOT_STARTED
  RUNNING
}

type MatchBettingLeague implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  imageUrl: String
  name: String!
  url: String
  videoGame: MatchBettingVideoGame!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingLeagueConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingLeagueEdge]
  total: Int
}

type MatchBettingLeagueEdge {
  node: MatchBettingLeague
  cursor: String!
}

type CreateMatchBettingLeagueSubscriptionPayload {
  matchBettingLeague: MatchBettingLeague!
}

type UpdateMatchBettingLeagueSubscriptionPayload {
  matchBettingLeague: MatchBettingLeague!
}

enum MatchBettingLeagueOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingMarketSelectionResult {
  INVALID
  LOST
  WON
}

type MatchBettingMarketSelection {
  name: String!
  odds: Float
  participantPlayer: MatchBettingPlayer
  participantPlayerId: ID
  participantTeam: MatchBettingTeam
  participantTeamId: ID
  participantType: MatchBettingOpponentType
  position: Int
  result: MatchBettingMarketSelectionResult
  template: String!
}

type MatchBettingMarket implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  game: MatchBettingGame
  gameId: ID
  match: MatchBettingMatch!
  matchId: ID!
  name: String!
  participantPlayer: MatchBettingPlayer
  participantPlayerId: ID
  participantTeam: MatchBettingTeam
  participantTeamId: ID
  participantType: MatchBettingOpponentType
  selections: [MatchBettingMarketSelection!]!
  status: MatchBettingMarketStatus!
  template: String!
  type: MatchBettingMarketType!
  videoGame: MatchBettingVideoGame!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingMarketConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingMarketEdge]
  total: Int
}

type MatchBettingMarketEdge {
  node: MatchBettingMarket
  cursor: String!
}

type ProcessMatchBettingMarketPayload {
  success: Boolean!
}

type CreateMatchBettingMarketSubscriptionPayload {
  matchBettingMarket: MatchBettingMarket!
}

type UpdateMatchBettingMarketSubscriptionPayload {
  matchBettingMarket: MatchBettingMarket!
}

input ProcessMatchBettingMarketInput {
  matchBettingMarketId: ID
  secret: String
}

enum MatchBettingMarketOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingMarketStatus {
  ACTIVE
  DEACTIVATED
  SETTLED
  SUSPENDED
}

enum MatchBettingMarketType {
  GAME
  MATCH
}

type MatchBettingMatchResult {
  opponentType: MatchBettingOpponentType!
  player: MatchBettingPlayer
  playerId: ID
  score: Int!
  team: MatchBettingTeam
  teamId: ID
}

enum MatchBettingMatchStatus {
  CANCELLED
  FINISHED
  LIVE
  NOT_BOOKED
  PENDING
  POSTPONED
  PRE_MATCH
  SETTLED
}

type MatchBettingMatchStream {
  embedUrl: String
  language: String!
  main: Boolean!
  official: Boolean!
  rawUrl: String
}

enum MatchBettingMatchType {
  BEST_OF
  CUSTOM
  FIRST_TO
  OW_BEST_OF
}

type MatchBettingMatch implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate
  draw: Boolean!
  endAt: SequelizeDate
  forfeit: Boolean!
  league: MatchBettingLeague!
  leagueId: ID!
  name: String!
  numberOfGames: Int!
  liveAvailable: Boolean!
  originalScheduledAt: SequelizeDate
  rescheduled: Boolean!
  results: [MatchBettingMatchResult!]!
  scheduledAt: SequelizeDate
  serie: MatchBettingSerie!
  serieId: ID!
  status: MatchBettingMatchStatus!
  streams: [MatchBettingMatchStream!]!
  tournament: MatchBettingTournament!
  tournamentId: ID!
  type: MatchBettingMatchType!
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  games(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    gameIds: [ID!]
    statuses: [MatchBettingGameStatus!]
  ): MatchBettingGameConnection!
  markets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    marketIds: [ID!]
    statuses: [MatchBettingMarketStatus!]
    types: [MatchBettingMarketType!]
  ): MatchBettingMarketConnection!
}

type MatchBettingMatchConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingMatchEdge]
  total: Int
}

type MatchBettingMatchEdge {
  node: MatchBettingMatch
  cursor: String!
}

type CreateMatchBettingMatchSubscriptionPayload {
  matchBettingMatch: MatchBettingMatch!
}

type UpdateMatchBettingMatchSubscriptionPayload {
  matchBettingMatch: MatchBettingMatch!
}

enum MatchBettingMatchOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingOpponentType {
  PLAYER
  TEAM
}

type MatchBettingPlayer implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  firstName: String
  imageUrl: String
  lastName: String
  name: String!
  nationality: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingPlayerConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingPlayerEdge]
  total: Int
}

type MatchBettingPlayerEdge {
  node: MatchBettingPlayer
  cursor: String!
}

type CreateMatchBettingPlayerSubscriptionPayload {
  matchBettingPlayer: MatchBettingPlayer!
}

type UpdateMatchBettingPlayerSubscriptionPayload {
  matchBettingPlayer: MatchBettingPlayer!
}

enum MatchBettingPlayerOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingProvider {
  PANDA_SCORE
}

type MatchBettingSerie implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate!
  description: String
  endAt: SequelizeDate
  fullName: String!
  league: MatchBettingLeague!
  leagueId: ID!
  name: String
  season: String
  tier: String
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  year: Int!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingSerieConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingSerieEdge]
  total: Int
}

type MatchBettingSerieEdge {
  node: MatchBettingSerie
  cursor: String!
}

type CreateMatchBettingSerieSubscriptionPayload {
  matchBettingSerie: MatchBettingSerie!
}

type UpdateMatchBettingSerieSubscriptionPayload {
  matchBettingSerie: MatchBettingSerie!
}

enum MatchBettingSerieOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type MatchBettingSlipBetItem {
  currency: String!
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type MatchBettingSlipSelection {
  externalMarketId: String
  game: MatchBettingGame
  gameId: ID
  market: MatchBettingMarket!
  marketName: String!
  marketSelectionName: String!
  marketId: ID!
  marketSelectionPosition: Int
  match: MatchBettingMatch!
  matchId: ID!
  odds: Float!
  probabilityWithMargin: Float
  result: MatchBettingMarketSelectionResult
}

type MatchBettingSlip implements Node {
  id: ID!
  provider: MatchBettingProvider
  bet: Float!
  betItems: [MatchBettingSlipBetItem!]
  betItemsAmount: Float!
  bigWin: Boolean!
  currency: String!
  excluded: Boolean!
  finalOdds: Float!
  finishedAt: SequelizeDate
  payout: Float!
  payoutType: MatchBettingSlipPayoutType!
  selections: [MatchBettingSlipSelection!]!
  status: MatchBettingSlipStatus!
  ticketsWon: Int!
  totalBet: Float!
  type: MatchBettingSlipType!
  user: User!
  userId: ID!
  winRemainder: Float
  winUserItem: UserItem
  winUserItemId: ID
  winUserItemValue: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingSlipConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingSlipEdge]
  total: Int
}

type MatchBettingSlipEdge {
  node: MatchBettingSlip
  cursor: String!
}

type CompleteMatchBettingSlipPayload {
  success: Boolean!
}

type CreateMatchBettingSlipPayload {
  matchBettingSlip: MatchBettingSlip!
}

type CreateMatchBettingSlipSubscriptionPayload {
  matchBettingSlip: MatchBettingSlip!
}

type UpdateMatchBettingSlipSubscriptionPayload {
  matchBettingSlip: MatchBettingSlip!
}

input CompleteMatchBettingSlipInput {
  matchBettingSlipId: ID!
  secret: String
}

input CreateMatchBettingSlipInput {
  amount: Float!
  finalOdds: Float!
  payoutType: MatchBettingSlipPayoutType!
  selections: [MatchBettingSlipSelectionInput!]!
  type: MatchBettingSlipType!
  userItemIds: [ID!]!
}

input MatchBettingSlipSelectionInput {
  marketId: ID!
  odds: Float!
  position: Int!
}

enum MatchBettingSlipOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingSlipPayoutType {
  COINS_ONLY
  ITEMS_AND_COINS
}

enum MatchBettingSlipStatus {
  ACTIVE
  LOST
  REFUNDED
  ROLLBACK
  WON
}

enum MatchBettingSlipType {
  MULTIPLE
  SINGLE
}

type MatchBettingTeam implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  acronym: String
  imageUrl: String
  location: String
  name: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingTeamConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingTeamEdge]
  total: Int
}

type MatchBettingTeamEdge {
  node: MatchBettingTeam
  cursor: String!
}

type CreateMatchBettingTeamSubscriptionPayload {
  matchBettingTeam: MatchBettingTeam!
}

type UpdateMatchBettingTeamSubscriptionPayload {
  matchBettingTeam: MatchBettingTeam!
}

enum MatchBettingTeamOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type MatchBettingTournament implements Node {
  id: ID!
  provider: MatchBettingProvider
  externalId: String
  externalSlug: String
  externalModifiedAt: SequelizeDate
  beginAt: SequelizeDate
  endAt: SequelizeDate
  league: MatchBettingLeague!
  leagueId: ID!
  liveAvailable: Boolean!
  name: String!
  serie: MatchBettingSerie!
  serieId: ID!
  videoGame: MatchBettingVideoGame!
  winnerPlayer: MatchBettingPlayer
  winnerPlayerId: ID
  winnerTeam: MatchBettingTeam
  winnerTeamId: ID
  winnerType: MatchBettingOpponentType
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type MatchBettingTournamentConnection {
  pageInfo: PageInfo!
  edges: [MatchBettingTournamentEdge]
  total: Int
}

type MatchBettingTournamentEdge {
  node: MatchBettingTournament
  cursor: String!
}

type CreateMatchBettingTournamentSubscriptionPayload {
  matchBettingTournament: MatchBettingTournament!
}

type UpdateMatchBettingTournamentSubscriptionPayload {
  matchBettingTournament: MatchBettingTournament!
}

enum MatchBettingTournamentOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum MatchBettingVideoGame {
  CALL_OF_DUTY
  CSGO
  DOTA2
  FIFA
  LOL
  OVERWATCH
  PUBG
  RAINBOW_SIX_SIEGE
  ROCKET_LEAGUE
  VALORANT
}

type MessageMeta {
  currency: String
  externalId: Int
  externalIdFull: ID
  externalModel: String
  name: String
  payoutCount: Int
  totalValue: Float
  userId: ID
  user: User
  giveawayId: ID
  giveaway: Giveaway
  userGiveawayIds: [ID!]
  userGiveaways: [UserGiveaway!]
  boxOpeningId: ID
  boxOpening: BoxOpening
  gemstoneBoostActivationId: ID
  gemstoneBoostActivation: GemstoneBoostActivation
}

type Message implements Node {
  id: ID!
  channel: String
  body: String
  userId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  user: User
  meta: JSON
  meta2: MessageMeta
  type: MessageType
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]
  total: Int
}

type MessageEdge {
  node: Message
  cursor: String!
}

type CreateMessagePayload {
  message: Message
}

type DeleteMessagesPayload {
  deletedAmount: Int
  messages: [Message]
}

type CreateMessageSubscriptionPayload {
  message: Message!
}

type DeleteMessageSubscriptionPayload {
  message: Message!
}

input CreateMessageInput {
  channel: MessageChannel!
  body: String!
}

input DeleteMessagesInput {
  id: ID
  userId: ID
}

enum MessageOrderBy {
  ID
  ID_DESC
}

enum MessageChannel {
  DE
  EN
  en
  HIGH_ROLLER
  PT
  SV
}

enum MessageType {
  BOX_OPENING
  GAME_JACKPOT_1X
  GAME_JACKPOT_2X
  GAME_JACKPOT_3X
  GEMSTONE_BOOST_ACTIVATION_CREATED
  GEMSTONE_BOX_WIN
  GIVEAWAY_COMPLETED
  GIVEAWAY_CREATED
  GIVEAWAY_STARTED
  GIVEAWAY_WIN
  JACKPOT_TICKET_WIN
}

type Note implements Node {
  id: ID!
  body: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID
  user: User
  creatorId: ID
  creator: User
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]
  total: Int
}

type NoteEdge {
  node: Note
  cursor: String!
}

type CreateNotePayload {
  note: Note
}

input CreateNoteInput {
  userId: ID!
  body: String!
}

enum NoteOrderBy {
  ID
  ID_DESC
}

type NotificationMessage implements Node {
  id: ID!
  notificationId: ID!
  notification: Notification!
  userId: ID!
  user: User!
  notificationOwnerId: ID!
  notificationOwner: User!
  content: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  readAt: SequelizeDate
  readById: ID
  readBy: User
}

type NotificationMessageConnection {
  pageInfo: PageInfo!
  edges: [NotificationMessageEdge]
  total: Int
}

type NotificationMessageEdge {
  node: NotificationMessage
  cursor: String!
}

type CreateNotificationMessagePayload {
  notificationMessage: NotificationMessage!
}

type MarkNotificationMessagesAsReadPayload {
  updatedCount: Int!
}

type CreateNotificationMessageSubscriptionPayload {
  notificationMessage: NotificationMessage!
}

type UpdateNotificationMessageSubscriptionPayload {
  notificationMessage: NotificationMessage!
}

input CreateNotificationMessageInput {
  content: String!
  notificationId: ID!
}

input MarkNotificationMessagesAsReadInput {
  ids: [ID!]!
}

enum NotificationMessageOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  READ_AT
}

type NotificationMeta {
  currency: String
  expiresAt: SequelizeDate
  itemVariantName: String
  name: String
  trackingUrl: String
  value: Float
}

type Notification implements Node {
  id: ID!
  userId: ID!
  user: User!
  type: NotificationType!
  creatorId: ID
  creator: User
  externalId: Int
  externalModel: String
  withMessages: Boolean!
  messages(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [NotificationMessageOrderBy]
    unreadOnly: Boolean
  ): NotificationMessageConnection
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  readAt: SequelizeDate
  meta: JSON
  meta2: NotificationMeta
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
  total: Int
}

type NotificationEdge {
  node: Notification
  cursor: String!
}

type MarkNotificationsAsReadPayload {
  updatedCount: Int!
}

type CreateNotificationSubscriptionPayload {
  notification: Notification!
}

type UpdateNotificationSubscriptionPayload {
  notification: Notification!
}

input MarkNotificationsAsReadInput {
  ids: [ID!]!
}

enum NotificationOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  READ_AT
}

enum NotificationType {
  ORDER_CREATED
  ORDER_SHIPPED
  UPDATE_ITEM_VARIANTS_FAIL
  UPDATE_ITEM_VARIANTS_SUCCESS
  USER_ACHIEVEMENT_CREATED
  USER_ITEM_CANCELLED
  USER_ITEM_PROCESSING
  USER_ITEM_REQUESTED
}

type OrderNote implements Node {
  id: ID!
  body: String
  orderId: ID
  creatorId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  private: Boolean
  order: Order
  creator: User
}

type OrderNoteConnection {
  pageInfo: PageInfo!
  edges: [OrderNoteEdge]
  total: Int
}

type OrderNoteEdge {
  node: OrderNote
  cursor: String!
}

type CreateOrderNotePayload {
  orderNote: OrderNote
}

input CreateOrderNoteInput {
  orderId: ID!
  body: String!
  private: Boolean
}

enum OrderNoteOrderBy {
  ID
  ID_DESC
}

type Order implements Node {
  id: ID!
  trackingUrl: String
  screenshotUrl: String
  cost: Float!
  deliveryCost: Float!
  currency: String!
  userId: ID
  creatorId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate!
  deliveryAt: SequelizeDate
  shippedAt: SequelizeDate
  user: User
  creator: User
  userItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): UserItemConnection!
  notes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): OrderNoteConnection!
  zincOrder: ZincOrder
  createdInSeconds: Int
  estimatedDeliveryInDays: String
  estimatedDeliveryStrategy: OrderEstimatedDeliveryStrategy
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]
  total: Int
}

type OrderEdge {
  node: Order
  cursor: String!
}

type CreateOrderPayload {
  order: Order
}

type UpdateOrderPayload {
  order: Order
}

type DeleteOrderPayload {
  order: Order
}

type SendOrderDeliveredEmailPayload {
  order: Order
}

type CreateOrderSubscriptionPayload {
  order: Order!
}

type UpdateOrderSubscriptionPayload {
  order: Order!
}

type DeleteOrderSubscriptionPayload {
  order: Order!
}

type RetailerDeliveryStats {
  retailer: Retailer
  ordersCreatedInSecondsAvg: Int
  estimatedDeliveryInHours: Int
  fromRequestedToDeliveredInHours: Int
}

type RetailerDeliveryStatsResponse {
  stats: [RetailerDeliveryStats!]
}

input CreateOrderInput {
  cost: Float!
  deliveryCost: Float!
  userItemIds: [ID]!
  screenshotUrl: String
  secret: String
  trackingUrl: String
  estimatedDeliveryInDays: String
}

input UpdateOrderInput {
  orderId: ID!
  cost: Float!
  deliveryCost: Float!
  trackingUrl: String
  screenshotUrl: String!
  estimatedDeliveryInDays: String
}

input DeleteOrderInput {
  orderId: ID!
}

input SendOrderDeliveredEmailInput {
  orderId: ID!
  secret: String!
}

enum OrderOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  COST
  COST_DESC
}

enum OrderEstimatedDeliveryStrategy {
  AUTO
  MANUAL
}

type PaymentOption implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  type: String!
  providerName: String!
  provider: PaymentProvider!
  methodName: String
  method: PaymentMethod
  whitelistedCountries: [String]!
  requiresProfile: Boolean!
  visible: Boolean!
  fixedFee: Decimal!
  percentageFee: Decimal!
  minDepositAmount: Decimal!
  maxDepositAmount: Decimal!
  minAmount: Decimal!
  maxAmount: Decimal!
  minExchangedAmount: Decimal!
  maxExchangedAmount: Decimal!
  order: Int!
  approximateAmount: Boolean!
  bonusPercent: Float!
  bonusMaxAmount: Float
  action: PaymentOptionAction!
  iconUrl: String!
}

enum PaymentOptionAction {
  DEPOSIT
  WITHDRAWAL
}

enum PaymentMethod {
  BCH
  BTC
  BTG
  DASH
  DOGE
  ETC
  ETH
  LTC
  USDT
  USDTE
  USDTT
  XRP
}

enum PaymentProvider {
  ALTERNATIVEPAYMENTS
  AMAZONPAY
  COIN_GATE
  COINS_PAID
  CUBITS
  ECOPAYZ
  FONDY
  G2APAY
  IPS
  PAY_BEAR
  PAY_OP
  PAYSAFECARD
  SAFE_CHARGE
  STRIPE
  TAPM
  WONDERLAND_PAY
}

type PromoCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  code: String
  balance: Float!
  currency: String!
  walletType: WalletType
  amount: Int!
  maxBalance: Float!
  percentageReward: Float!
  redeemCount: Int!
  maxRedeemCount: Int
  minDepositRequirement: Float!
  expired: Boolean!
  type: PromoCodeType!
  itemVariantId: ID
  itemVariant: ItemVariant
  boxId: ID
  box: Box
  affiliateUserId: ID
  affiliateUser: User
  market: Market!
  marketId: ID!
  users: [User]
}

type PromoCodeConnection {
  pageInfo: PageInfo!
  edges: [PromoCodeEdge]
  total: Int
}

type PromoCodeEdge {
  node: PromoCode
  cursor: String!
}

type PromoCodePayload {
  promoCode: PromoCode
}

type CreateAffiliatePromoCodePayload {
  promoCode: PromoCode
}

type UpdateAffiliatePromoCodePayload {
  promoCode: PromoCode
  id: ID!
}

type CreatePromoCodesPayload {
  affiliateUser: User
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  box: Box
  boxId: ID
  codes: [String!]
  walletType: WalletType
  percentageReward: Float
  maxBalance: Float
  itemVariant: ItemVariant
  itemVariantId: ID
  marketId: ID!
  maxRedeemCount: Int
  minDepositRequirement: Float
  type: PromoCodeType!
}

type CreatePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type UpdatePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type DeletePromoCodeSubscriptionPayload {
  promoCode: PromoCode!
}

type PromoCodeTimer {
  status: UserAffiliateStatus
  secondsLeft: Int
}

enum PromoCodeOrderBy {
  ID
  ID_DESC
  BALANCE_DESC
  BALANCE
  CREATED_AT_DESC
  CREATED_AT
  MAX_REDEEM_COUNT_DESC
  MAX_REDEEM_COUNT
  REDEEM_COUNT_DESC
  REDEEM_COUNT
}

input UsePromoCodeInput {
  code: String!
  recaptcha: String!
  visualRecaptcha: String
}

input DeletePromoCodeInput {
  id: ID!
}

input UpdatePromoCodeInput {
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  boxId: ID
  code: String!
  walletType: WalletType
  id: ID!
  itemVariantId: ID
  maxBalance: Float
  maxRedeemCount: Int
  minDepositRequirement: Float
  percentageReward: Float
  type: PromoCodeType!
}

input CreateAffiliatePromoCodeInput {
  affiliateUserId: ID
  code: String!
  marketId: ID
}

input UpdateAffiliatePromoCodeInput {
  id: ID!
  code: String!
  affiliateUserId: ID
}

input CreatePromoCodeInput {
  affiliateUserId: ID
  amount: Int!
  balance: Float!
  boxId: ID
  codes: [String!]!
  walletType: WalletType
  itemVariantId: ID
  marketId: ID!
  maxBalance: Float!
  maxRedeemCount: Int
  minDepositRequirement: Float
  percentageReward: Float!
  type: PromoCodeType!
}

enum PromoCodeType {
  GIFT_CARD
  PROMOTION
}

enum ProvablyFairVersion {
  ALEA
  CRYPTO
}

type PvpBetBetItem {
  itemVariantId: ID!
  itemVariant: ItemVariant!
  userItemId: ID!
  userItem: UserItem!
  value: Float!
}

type PvpBetRollsHistoryItem {
  nonce: Int!
  pvpBetId: ID!
  pvpBet: PvpBet!
  pvpBetIdAsNumber: Int!
  rollId: ID!
  roll: Roll!
  rollNumber: Int!
  rollResult: String!
  status: PvpBetStatus!
}

enum PvpBetStatus {
  CREATED
  DRAW
  FINISHED
  LOST
  REFUNDED
  WAITING_FOR_GAME_END
  WON
}

type PvpBet implements Node {
  id: ID!
  betId: Int!
  pvpGameId: ID!
  pvpGame: PvpGame!
  pvpRoundId: ID!
  pvpRound: PvpRound!
  userId: ID!
  user: User!
  status: PvpBetStatus!
  gameType: PvpGameType!
  currency: String!
  houseEdgePercent: Float!
  bet: Float!
  betItemsAmount: Float!
  totalBet: Float!
  betItems: [PvpBetBetItem!]
  betRemainder: Float
  payout: Float
  houseEdge: Float
  winUserItemId: ID
  winUserItem: UserItem
  winUserItemValue: Float
  winRemainder: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  finishedAt: SequelizeDate
  selection: Int
  serverSeedId: ID
  serverSeed: Seed
  rollId: ID
  roll: Roll
  rollResult: String
  rollNumber: Int!
  rollsHistory: [PvpBetRollsHistoryItem!]
  bigWin: Boolean!
  ticketsWon: Int!
  boxOpening: BoxOpening
  byPvpBot: Boolean!
}

type PvpBetConnection {
  pageInfo: PageInfo!
  edges: [PvpBetEdge]
  total: Int
}

type PvpBetEdge {
  node: PvpBet
  cursor: String!
}

type CreatePvpBetSubscriptionPayload {
  pvpBet: PvpBet!
}

type UpdatePvpBetSubscriptionPayload {
  pvpBet: PvpBet!
}

enum PvpBetOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

type PvpBot implements Node {
  id: ID!
  status: PvpBotStatus!
  userId: ID!
  user: User!
  marketId: ID!
  market: Market!
  currency: String!
  displayName: String!
  minBetAmount: Float!
  maxBetAmount: Float!
  alertOnReserveUse: Boolean!
  remainingReserveUses: Int!
  reserveBalance: Float!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type PvpBotConnection {
  pageInfo: PageInfo!
  edges: [PvpBotEdge]
  total: Int
}

type PvpBotEdge {
  node: PvpBot
  cursor: String!
}

type CallPvpBotPayload {
  success: Boolean!
}

type CallPvpBotForRematchPayload {
  success: Boolean!
}

type CreatePvpBotPayload {
  pvpBot: PvpBot!
}

type UpdatePvpBotPayload {
  pvpBot: PvpBot!
}

type CreatePvpBotSubscriptionPayload {
  pvpBot: PvpBot!
}

type UpdatePvpBotSubscriptionPayload {
  pvpBot: PvpBot!
}

input CallPvpBotInput {
  pvpGameId: ID!
}

input CallPvpBotForRematchInput {
  pvpGameId: ID!
  secret: String
  userId: ID!
}

input CreatePvpBotInput {
  alertOnReserveUse: Boolean
  displayName: String!
  marketId: ID!
  maxBetAmount: Float!
  minBetAmount: Float!
  remainingReserveUses: Int!
  reserveBalance: Float!
  status: PvpBotStatus!
}

input UpdatePvpBotInput {
  data: UpdatePvpBotDataInput!
  pvpBotId: ID!
}

input UpdatePvpBotDataInput {
  alertOnReserveUse: Boolean
  displayName: String
  maxBetAmount: Float
  minBetAmount: Float
  remainingReserveUses: Int
  reserveBalance: Float
  status: PvpBotStatus
}

enum PvpBotOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum PvpBotStatus {
  DISABLED
  ENABLED
  SUSPENDED
}

type PvpDebugInfo {
  autoExit: Boolean
  createdByUserId: ID
  createdByUser: User
  exitedByUserId: ID
  exitedByUser: User
  playStartedByUserId: ID
  playStartedByUser: User
  staffExit: Boolean
}

type PvpGameActiveRound {
  id: ID!
  number: Int!
  round: PvpRound!
  status: PvpRoundStatus!
}

type PvpGamePlayer {
  exitedAt: SequelizeDate
  excluded: Boolean
  exiter: Boolean
  isPvpBot: Boolean!
  joinedAt: SequelizeDate
  status: PvpGamePlayerStatus!
  timesWon: Int
  totalBet: Float
  totalPayout: Float
  totalProfit: Float
  userId: ID!
  user: User!
  xpRewarded: Int
}

enum PvpGamePlayerStatus {
  EXITED
  JOINED
}

enum PvpGameType {
  BOX
  COIN_FLIP
  DICE
}

type PvpGame implements Node {
  id: ID!
  userId: ID!
  user: User!
  status: PvpGameStatus!
  type: PvpGameType!
  currency: String!
  initialBet: Float!
  initialWinItemVariantId: ID
  initialWinItemVariant: ItemVariant
  initialWinItemVariantValue: Float
  houseEdgePercent: Float!
  totalBet: Float
  totalPayout: Float
  totalHouseEdge: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  startedAt: SequelizeDate
  finishedAt: SequelizeDate
  players: [PvpGamePlayer!]!
  minPlayers: Int!
  maxPlayers: Int
  totalRoundCount: Int!
  totalBetCount: Int!
  activeRoundNumber: Int
  activeRound: PvpGameActiveRound
  rounds(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    pvpRoundId: ID
    statuses: [PvpRoundStatus!]
  ): PvpRoundConnection!
  bets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    pvpBetId: ID
    statuses: [PvpBetStatus!]
    userId: ID
  ): PvpBetConnection!
  debugInfo: PvpDebugInfo
  serverSeedId: ID
  serverSeed: Seed
  clientSeedId: ID
  clientSeed: Seed
  blockNumber: String
  boxOpenings(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): BoxOpeningConnection
}

type PvpGameConnection {
  pageInfo: PageInfo!
  edges: [PvpGameEdge]
  total: Int
}

type PvpGameEdge {
  node: PvpGame
  cursor: String!
}

type CleanUpStalePvpGamesPayload {
  success: Boolean!
}

type CreatePvpGamePayload {
  pvpBet: PvpBet
  pvpBets: [PvpBet!]
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
}

type ExitPvpGamePayload {
  pvpGame: PvpGame!
}

type JoinPvpGamePayload {
  pvpBet: PvpBet
  pvpBets: [PvpBet!]
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
}

type PlayPvpGamePayload {
  pvpBets: [PvpBet!]!
  pvpGame: PvpGame!
  pvpRound: PvpRound
  pvpRounds: [PvpRound!]
  success: Boolean!
}

type CreatePvpGameSubscriptionPayload {
  pvpGame: PvpGame!
}

type PlayPvpGameSubscriptionPayload {
  pvpGameId: ID!
  pvpRoundId: ID
}

type UpdatePvpGameSubscriptionPayload {
  pvpGame: PvpGame!
}

input CleanUpStalePvpGamesInput {
  lastRoundNumber: Int
  pvpGameId: ID
  secret: String!
}

input CreatePvpGameInput {
  amount: Float!
  boxes: [PvpGameBoxInput!]
  selection: Int
  type: PvpGameType!
  userItemIds: [ID!]!
}

input PvpGameBoxInput {
  boxId: ID!
  roundNumber: Int!
}

input ExitPvpGameInput {
  pvpGameId: ID!
}

input JoinPvpGameInput {
  pvpGameId: ID!
  selection: Int
}

input PlayPvpGameInput {
  pvpGameId: ID!
  secret: String
}

enum PvpGameOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  INITIAL_BET
  INITIAL_BET_DESC
}

enum PvpGameStatus {
  CANCELLED
  CREATED
  STARTED
  FINISHED
}

type PvpRoundPlayer {
  excluded: Boolean
  exitedAt: SequelizeDate
  exiter: Boolean
  isPvpBot: Boolean!
  joinedAt: SequelizeDate
  payout: Float
  rolls: [PvpBetRollsHistoryItem!]
  status: PvpRoundPlayerStatus!
  totalGamePayout: Float
  userId: ID!
  user: User!
  winRemainder: Float
  winUserItemId: ID
  winUserItem: UserItem
}

enum PvpRoundPlayerStatus {
  DRAW
  EXITED
  JOINED
  LOST
  REFUNDED
  WAITING
  WON
}

type PvpRound implements Node {
  id: ID!
  roundId: Int!
  pvpGameId: ID!
  pvpGame: PvpGame!
  userId: ID!
  user: User!
  roundNumber: Int!
  status: PvpRoundStatus!
  hasDraws: Boolean!
  gameType: PvpGameType!
  currency: String!
  bet: Float!
  betChanged: Boolean!
  houseEdgePercent: Float!
  totalBet: Float
  totalPayout: Float
  totalHouseEdge: Float
  winItemVariantId: ID
  winItemVariant: ItemVariant
  winItemVariantValue: Float
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  startedAt: SequelizeDate
  finishedAt: SequelizeDate
  players: [PvpRoundPlayer!]!
  selections: JSON
  biggestWinValue: Float
  serverSeedId: ID
  serverSeed: Seed
  blockNumber: String
  rollId: ID
  roll: Roll
  rollResult: String
  totalBetCount: Int!
  bets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    pvpBetId: ID
    statuses: [PvpBetStatus!]
    userId: ID
  ): PvpBetConnection!
  debugInfo: PvpDebugInfo
  boxId: ID
  box: Box
}

type PvpRoundConnection {
  pageInfo: PageInfo!
  edges: [PvpRoundEdge]
  total: Int
}

type PvpRoundEdge {
  node: PvpRound
  cursor: String!
}

type CreatePvpRoundPayload {
  pvpBet: PvpBet!
  pvpGame: PvpGame!
  pvpRound: PvpRound!
}

type CreatePvpRoundSubscriptionPayload {
  pvpRound: PvpRound!
}

type UpdatePvpRoundSubscriptionPayload {
  pvpRound: PvpRound!
}

input CreatePvpRoundInput {
  doubleBetAmount: Boolean!
  pvpGameId: ID!
  selection: Int
}

enum PvpRoundOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  ROUND_NUMBER
  ROUND_NUMBER_DESC
}

enum PvpRoundStatus {
  CANCELLED
  CREATED
  FINISHED
  STARTED
  WAITING_FOR_GAME_END
}

# An integer between 1 and 250
scalar PaginationAmount

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ResetPasswordPayload {
  success: Boolean!
  user: User
}

input ResetPasswordInput {
  hash: String!
  password: String!
  confirmPassword: String!
  recaptcha: String!
  visualRecaptcha: String
}

type Roll implements Node {
  id: ID!
  userId: ID
  user: User
  serverSeedId: ID
  serverSeed: Seed
  clientSeedId: ID
  clientSeed: Seed
  game: GameType
  nonce: Int
  value: Int
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type RollConnection {
  pageInfo: PageInfo!
  edges: [RollEdge]
  total: Int
}

type RollEdge {
  node: Roll
  cursor: String!
}

type CreateRollSubscriptionPayload {
  roll: Roll!
}

enum GameType {
  BOXES
  CRASH
  DICE
  MATCH_BETTING
  PVP
  PVP_BOX
  PVP_COIN_FLIP
  PVP_DICE
  ROULETTE
}

enum RollOrderBy {
  ID
  ID_DESC
  DESC
}

type RollHistory {
  id: ID!
  maxId: ID!
  minId: ID!
  serverSeedId: ID
  clientSeedId: ID
  minNonce: Int
  maxNonce: Int
  game: GameType
  serverSeed: Seed
  clientSeed: Seed
  createdAt: SequelizeDate
  createdAtDate: String
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# Decimal value with a maximum of 2 decimal digits.
scalar Decimal

# A special custom Scalar type for Dates that converts to a ISO formatted string
scalar SequelizeDate

# The `BigInt` scalar type represents non-fractional signed whole numeric values. BigInt can represent values between -(2^53) + 1 and 2^53 - 1.
scalar BigInt

# The `Upload` scalar type represents a file upload.
scalar Upload

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type CommitVersion {
  sha: String
  shortSha: String
  tag: String
}

type Seed implements Node {
  id: ID!
  userId: ID!
  type: SeedType
  value: String
  hash: String
  future: Boolean
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  user: User
}

type SeedConnection {
  pageInfo: PageInfo!
  edges: [SeedEdge]
  total: Int
}

type SeedEdge {
  node: Seed
  cursor: String!
}

type ChangeSeedPayload {
  seed: Seed!
  seeds: [Seed!]!
}

input ChangeSeedInput {
  type: SeedType!
  value: String
}

enum SeedOrderBy {
  ID
  ID_DESC
}

enum SeedType {
  SERVER
  CLIENT
}

type Setting implements Node {
  id: ID!
  key: String!
  description: String
  value: String
  type: SettingType!
  visibleByRoles: [UserRole!]
  editableByRoles: [UserRole!]
}

type UpdateSettingPayload {
  setting: Setting
}

type FlushSettingCachePayload {
  settings: [Setting]
}

type UpdateSettingSubscriptionPayload {
  setting: Setting!
}

input UpdateSettingInput {
  key: String!
  value: String
}

input FlushSettingInput {
  unused: Boolean
}

enum SettingType {
  BOOLEAN
  FLOAT
  INTEGER
  STRING
  TEXT
}

type ShipTo {
  address1: String!
  address2: String
  city: String!
  country: String!
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String
}

type SteamAsset implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  lockExpiresAt: SequelizeDate
  itemVariantId: ID
  itemVariant: ItemVariant
  steamBotId: ID
  steamBot: SteamBot
  incomingSteamOfferId: ID
  incomingSteamOffer: SteamOffer
  outgoingSteamOfferId: ID
  outgoingSteamOffer: SteamOffer
  appId: String
  contextId: String
  assetId: String
  classId: String
  instanceId: String
  iconUrl: String
  inspectLink: String
  marketHashName: String
  depositValue: Float
  withdrawValue: Float
  currency: String!
}

type SteamAssetConnection {
  pageInfo: PageInfo!
  edges: [SteamAssetEdge]
  total: Int
}

type SteamAssetEdge {
  node: SteamAsset
  cursor: String!
}

type BanSteamBotAssetsPayload {
  success: Boolean!
}

type UpdateAvailableAssetsPayload {
  success: Boolean!
}

type CreateSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

type UpdateSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

type DeleteSteamAssetSubscriptionPayload {
  steamAsset: SteamAsset!
}

input BanSteamBotAssetsInput {
  steamBotId: ID!
}

input UpdateAvailableAssetsInput {
  itemIds: [ID!]!
}

enum SteamAssetOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DEPOSIT_VALUE
  DEPOSIT_VALUE_DESC
  LOCK_EXPIRES_AT
  LOCK_EXPIRES_AT_DESC
}

type SteamBot implements Node {
  id: ID!
  username: String
  steamTradeUrl: String
  displayName: String!
  steamId: String
  country: String
  deposit: Boolean
  withdraw: Boolean
  enabled: Boolean
  activeAt: SequelizeDate
  activeUntil: SequelizeDate
  inventorySeenAt: SequelizeDate
  lastKnownHost: String
  banned: Boolean
  steamAccountPassword: String
  steamAccountLoginKey: String
  steamAccountSharedSecret: String
  steamAccountIdentitySecret: String
  steamGame: Int
  httpProxy: String
  httpsProxy: String
  minAcceptableTradeValue: Float
  maxAcceptableTradeValue: Float
  maxStockValue: Float
  maxStockCount: Int
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  steamAssets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): SteamAssetConnection
  steamAssetValue: Float
  userId: ID
  user: User
  type: SteamBotType!
}

type SteamBotConnection {
  pageInfo: PageInfo!
  edges: [SteamBotEdge]
  total: Int
}

type SteamBotEdge {
  node: SteamBot
  cursor: String!
}

type CheckSteamBotActivityPlayload {
  success: Boolean!
}

type CreateSteamBotPayload {
  steamBot: SteamBot
}

type CreateSteamBotsPayload {
  steamBots: [SteamBot!]!
  total: Int!
}

type UpdateSteamBotPayload {
  steamBot: SteamBot
}

type DeleteSteamBotPayload {
  steamBot: SteamBot
}

type WakeUpSteamBotPayload {
  steamBot: SteamBot
}

type SleepSteamBotPayload {
  steamBot: SteamBot
}

type CreateSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

type UpdateSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

type DeleteSteamBotSubscriptionPayload {
  steamBot: SteamBot!
}

input CheckSteamBotActivityInput {
  secret: String!
}

input CreateUpdateSteamBotInput {
  steamId: String!
  username: String!
  displayName: String!
  type: SteamBotType
  steamTradeUrl: String
  active: Boolean
  deposit: Boolean
  withdraw: Boolean
  enabled: Boolean
  banned: Boolean
  steamAccountPassword: String
  steamAccountLoginKey: String
  steamAccountSharedSecret: String
  steamAccountIdentitySecret: String
  httpProxy: String
  httpsProxy: String
  minAcceptableTradeValue: Float
  maxAcceptableTradeValue: Float
  maxStockValue: Float
  maxStockCount: Int
  steamGame: Int
}

enum SteamBotOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum SteamBotType {
  INFO
  TRADE
}

type SteamOfferItemVariant implements Node {
  id: ID!
  steamOfferId: ID
  steamOffer: SteamOffer
  itemVariantId: ID
  itemVariant: ItemVariant
  direction: OfferDirection
  createdAt: SequelizeDate
  updatedAt: SequelizeDate
}

type SteamOfferItemVariantConnection {
  pageInfo: PageInfo!
  edges: [SteamOfferItemVariantEdge]
  total: Int
}

type SteamOfferItemVariantEdge {
  node: SteamOfferItemVariant
  cursor: String!
}

enum SteamOfferItemVariantOrderBy {
  ID
  ID_DESC
}

enum OfferDirection {
  GIVE
  TAKE
}

type SteamOffer implements Node {
  id: ID!
  state: SteamOfferState
  steamBotId: ID
  steamBot: SteamBot
  steamTradeUrl: String
  userId: ID
  user: User
  userItem: UserItem
  steamOfferItemVariants: SteamOfferItemVariantConnection
  outgoingSteamAssets: SteamAssetConnection
  tradeOfferId: String
  availableAt: SequelizeDate!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  expiresAt: SequelizeDate
  trade: Trade
}

type SteamOfferConnection {
  pageInfo: PageInfo!
  edges: [SteamOfferEdge]
  total: Int
}

type SteamOfferEdge {
  node: SteamOffer
  cursor: String!
}

type DeleteSteamOfferPayload {
  steamOffer: SteamOffer
}

type ReadySteamOfferPayload {
  steamOffer: SteamOffer
}

type CreateSteamOffersPayload {
  steamOffers: [SteamOffer]
}

type CreateSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

type UpdateSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

type DeleteSteamOfferSubscriptionPayload {
  steamOffer: SteamOffer!
}

input ReadySteamOfferInput {
  steamOfferId: ID
  tradeId: ID
}

input CreateSteamOffersInput {
  steamAssetIds: [ID!]
  steamTradeUrl: ID
  userId: ID
}

enum SteamOfferOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  EXPIRES_AT
  EXPIRES_AT_DESC
  AVAILABLE_AT
  AVAILABLE_AT_DESC
}

enum SteamOfferState {
  ACCEPTED
  ACTIVE
  CANCELED_BY_SECOND_FACTOR
  CANCELED
  COUNTERED
  CREATED_NEEDS_CONFIRMATION
  DECLINED
  EXPIRED
  IN_ESCROW
  INVALID_ITEMS
  INVALID
  PROCESSING
}

type UpdateSteamStatusPayload {
  status: String!
}

type SteamUserTradeHistory {
  steamTrades: [SteamTradeFromHistory!]!
}

type SteamTradeFromHistory {
  tradeid: String!
  steamid_other: String!
  time_init: Int!
  status: Int!
  amountOfAssetsGiven: JSON
  amountOfAssetsReceived: JSON
}

input UpdateSteamStatusInput {
  addTask: Boolean
  secret: String
}

enum SteamAppName {
  CSGO
  DOTA2
  H1Z1
  PUBG
  RUST
  STEAM
}

type CreateSupportTicketPayload {
  status: String!
  message: String!
}

input CreateSupportTicketInput {
  email: String!
  supportMessage: String!
}

type Tag implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  name: String!
  visible: Boolean!
  boxes: [Box]
  position: Int!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]
  total: Int
}

type TagEdge {
  node: Tag
  cursor: String!
}

type CreateTagPayload {
  tag: Tag
}

type UpdateTagPayload {
  tag: Tag
}

type DeleteTagPayload {
  tag: Tag
}

type CreateTagSubscriptionPayload {
  tag: Tag!
}

type UpdateTagSubscriptionPayload {
  tag: Tag!
}

type DeleteTagSubscriptionPayload {
  tag: Tag!
}

input CreateTagInput {
  name: String!
  visible: Boolean!
  position: Int
}

input UpdateTagInput {
  id: ID!
  name: String!
  visible: Boolean!
  position: Int
}

input DeleteTagInput {
  id: ID!
}

enum TagOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
  POSITION
  POSITION_DESC
}

type PurgeTaskQueuePayload {
  success: Boolean!
}

input PurgeTaskQueueInput {
  name: String!
}

type Team implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  name: String!
  totalGemstones(
    createdAtMinDate: SequelizeDate!
    createdAtMaxDate: SequelizeDate!
  ): Float!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]
  total: Int
}

type TeamEdge {
  node: Team
  cursor: String!
}

enum TeamOrderBy {
  ID
  ID_DESC
}

type Ticket implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  jackpotId: ID
  jackpot: Jackpot
  userId: ID!
  user: User!
  teamId: ID
  sequentialNumber: Int
}

type TicketConnection {
  pageInfo: PageInfo!
  edges: [TicketEdge]
  total: Int
}

type TicketEdge {
  node: Ticket
  cursor: String!
}

type CreateTicketSubscriptionPayload {
  ticket: Ticket!
}

enum TicketOrderBy {
  ID
  ID_DESC
}

type TradeItem implements Node {
  id: ID!
  tradeId: ID!
  trade: Trade!
  marketName: String!
  value: Float!
  customValue: Boolean!
  currency: String!
  itemVariantId: ID!
  itemVariant: ItemVariant
  markupPercent: Float!
}

type TradeItemConnection {
  pageInfo: PageInfo!
  edges: [TradeItemEdge]
  total: Int
}

type TradeItemEdge {
  node: TradeItem
  cursor: String!
}

enum TradeItemOrderBy {
  ID
  ID_DESC
}

type Trade implements Node {
  id: ID!
  status: TradeStatus!
  cancelReason: CancelReason
  depositorUserId: ID
  depositor: User
  withdrawerUserId: ID
  withdrawer: User
  totalValue: Float!
  customValue: Boolean!
  currency: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  expiresAt: SequelizeDate
  suspectedTraderCanJoinAfter: SequelizeDate!
  steamOfferId: ID
  steamOffer: SteamOffer
  steamAppId: String
  steamAppName: SteamAppName
  depositorSentItemsAt: SequelizeDate
  withdrawerReceivedItemsAt: SequelizeDate
  joinedAt: SequelizeDate
  processingAt: SequelizeDate
  cooldownAt: SequelizeDate
  finishedAt: SequelizeDate
  storageUnitLastModificationAt: SequelizeDate
  tradeItems: [TradeItem]
  withdrawerSteamTradeUrl: String
  type: TradeType
  promoCodeId: ID
  promoCode: PromoCode
  trackingType: TradeTrackingType
  steamTradeOfferId: String
  markupPercent: Float!
}

type TradeConnection {
  pageInfo: PageInfo!
  edges: [TradeEdge]
  total: Int
}

type TradeEdge {
  node: Trade
  cursor: String!
}

type CreateTradePayload {
  trade: Trade!
}

type JoinTradePayload {
  trade: Trade!
}

type JoinTradesPayload {
  trades: [Trade]!
}

type AutoJoinTradePayload {
  trade: Trade
}

type ProcessTradePayload {
  trade: Trade!
}

type CancelTradePayload {
  trade: Trade!
}

type CompleteTradePayload {
  trade: Trade!
}

type TrackTradePayload {
  success: Boolean!
}

type CleanUpTradesPayload {
  success: Boolean!
}

type CleanUpCooldownTradesPayload {
  success: Boolean!
}

type CreateTradeSubscriptionPayload {
  trade: Trade!
}

type UpdateTradeSubscriptionPayload {
  trade: Trade!
}

type UpdateTradesMarkupPayload {
  trades: [Trade!]!
}

type RemoveFromListedTradeSubscriptionPayload {
  tradeId: ID!
}

input AutoJoinTradeInput {
  tradeId: ID!
  secret: String
}

input CreateTradeInput {
  tradeItems: [TradeItemInput!]!
  recaptcha: String!
  visualRecaptcha: String
  promoCode: String
}

input TradeItemInput {
  itemVariantId: ID!
  value: Float
}

input JoinTradeInput {
  tradeId: ID!
  recaptcha: String!
  visualRecaptcha: String
}

input JoinTradesInput {
  tradeIds: [ID!]!
  recaptcha: String!
  visualRecaptcha: String
}

input ProcessTradeInput {
  tradeId: ID!
}

input CancelTradeInput {
  tradeId: ID!
}

input CompleteTradeInput {
  tradeId: ID!
}

input TrackTradeInput {
  tradeId: ID!
  payload: JSON!
  secret: String!
}

input CleanUpTradesInput {
  secret: String!
}

input CleanUpCooldownTradesInput {
  secret: String!
}

input UpdateTradesMarkupInput {
  itemVariantIds: [ID!]!
  secret: String
}

enum TradeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  BEST_DEALS
  MARKUP_PERCENT
  MARKUP_PERCENT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  TOTAL_VALUE
  TOTAL_VALUE_DESC
}

enum TradeStatus {
  CANCELLED
  COMPLETED
  COMPLETED_PRIVATE
  COMPLETED_WITH_STORAGE_UNIT
  FROZEN
  JOINED
  LISTED
  PROCESSING
  COOLDOWN
}

enum CancelReason {
  EXPIRED
  NO_CONFIRMATION
  REVOKED_API_KEY
  USER_CANCELLED
}

enum TradeType {
  TRADER
  WAX_PEER
}

enum TradeTrackingType {
  API_KEY_DEPOSITOR
  API_KEY_WITHDRAWER
  INVENTORY
  STEAM_OFFER
}

type TransactionUserItem {
  itemVariantId: ID
  userItemId: ID
  value: Float
}

type TransactionMeta {
  apmExternalEmail: String
  apmTransactionId: String
  minimumExchangedAmount: Float
  originalAmount: Float
  originalExchangedAmount: Float
  originalExchangeRate: Float
  externalTransactionIds: [String]
  withdrawalApprovedByUserId: ID
  withdrawalApprovedByUser: User
}

type Transaction implements Node {
  id: ID!
  type: TransactionType!
  status: TransactionStatus!
  externalId: String
  promoCodeId: ID
  promoCode: PromoCode
  provider: PaymentProvider
  method: PaymentMethod
  url: String
  amount: Decimal!
  currency: String!
  exchangedAmount: Float
  exchangeRate: Float
  cryptoAddress: String
  ipAddress: String
  userId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  renderData: JSON
  meta: TransactionMeta
  user: User
  paymentOptionId: ID
  paymentOption: PaymentOption
  bonusPercent: Float!
  bonusMaxAmount: Float
  bonusAmount: Float!
  feeAmount: Float!
  userItems: [TransactionUserItem]
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]
  total: Int
}

type TransactionEdge {
  node: Transaction
  cursor: String!
}

type ApproveWithdrawalTransactionPayload {
  transaction: Transaction
}

type CreateTransactionPayload {
  transaction: Transaction
}

type UpdateTransactionPayload {
  transaction: Transaction
}

type CreateTransactionSubscriptionPayload {
  transaction: Transaction!
}

type UpdateTransactionSubscriptionPayload {
  transaction: Transaction!
}

input CreateTransactionInput {
  amount: Float!
  cryptoAddress: String
  paymentOptionId: ID!
  preferredCurrency: String
  promoCode: String
  sourceCurrency: String
  token: String
  userItemIds: [ID!]
  type: TransactionType
  provider: PaymentProvider
  method: PaymentMethod
  recaptcha: String
  visualRecaptcha: String
}

input UpdateTransactionInput {
  transactionId: ID!
  status: TransactionStatus!
}

input ApproveWithdrawalTransactionInput {
  approved: Boolean!
  transactionId: ID!
}

enum TransactionOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  AMOUNT
  AMOUNT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
}

enum TransactionStatus {
  CANCELED
  COMPLETED
  FAILED
  PENDING
  PENDING_APPROVAL
  PRE_APPROVAL
  STARTED
}

type UserAchievement implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID!
  user: User!
  achievementId: ID!
  achievement: Achievement!
  claimedAt: SequelizeDate
  bonusAmount: Float
  rewards: [AchievementReward!]!
  xpAmount: Int
  bonusExpiresAt: SequelizeDate
  rewardsExpireAt: SequelizeDate
  type: AchievementType
}

type UserAchievementConnection {
  pageInfo: PageInfo!
  edges: [UserAchievementEdge]
  total: Int
}

type UserAchievementEdge {
  node: UserAchievement
  cursor: String!
}

type ClaimUserAchievementPayload {
  userAchievement: UserAchievement!
}

type CreateUserAchievementPayload {
  userAchievement: UserAchievement!
}

type TriggerUserAchievementPayload {
  success: Boolean
}

type FlushUserAchievementCachePayload {
  userAchievementIds: [ID]
}

type CreateUserAchievementSubscriptionPayload {
  userAchievement: UserAchievement!
}

type UpdateUserAchievementSubscriptionPayload {
  userAchievement: UserAchievement!
}

input ClaimUserAchievementInput {
  userAchievementId: ID!
}

input CreateUserAchievementInput {
  achievementId: ID!
  userId: ID!
}

input TriggerUserAchievementInput {
  achievementType: AchievementType!
  secret: String!
  triggerData: TriggerDataInput!
}

input TriggerDataInput {
  amount: Float
  channel: String
  contents: String
  currency: String
  externalId: String!
  gameType: GameType
  userId: ID!
  userItemUsed: Boolean
}

input FlushUserAchievementCacheInput {
  userId: ID!
}

enum UserAchievementOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

type UserBox implements Node {
  id: ID!
  status: UserBoxStatus!
  acquiredValue: Float!
  consumedValue: Float!
  currency: String!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  userId: ID!
  user: User!
  boxId: ID!
  box: Box!
  ancestorBoxId: ID
  ancestorBox: Box
  pvpGameId: ID
  pvpGame: PvpGame
  pvpBetId: ID
  pvpBet: PvpBet
}

type UserBoxConnection {
  pageInfo: PageInfo!
  edges: [UserBoxEdge]
  total: Int
}

type UserBoxEdge {
  node: UserBox
  cursor: String!
}

type PurchaseBoxPayload {
  box: Box
  userBoxes: [UserBox]
}

type RefundUserBoxPayload {
  userBox: UserBox
}

type CreateUserBoxSubscriptionPayload {
  userBox: UserBox!
}

type UpdateUserBoxSubscriptionPayload {
  userBox: UserBox!
}

input PurchaseBoxInput {
  boxId: ID!
  amount: Int
}

input RefundUserBoxInput {
  id: ID!
}

enum UserBoxOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum UserBoxStatus {
  CONSUMED
  AVAILABLE
}

type UserCommunication implements Node {
  id: ID!
  userId: ID!
  user: User!
  mutedUserId: ID!
  mutedUser: User!
}

type UserCommunicationConnection {
  pageInfo: PageInfo!
  edges: [UserCommunicationEdge]
  total: Int
}

type UserCommunicationEdge {
  node: UserCommunication
  cursor: String!
}

type CreateUserCommunicationPayload {
  userCommunication: UserCommunication!
}

type DeleteUserCommunicationPayload {
  userCommunication: UserCommunication!
}

type CreateUserCommunicationSubscriptionPayload {
  userCommunication: UserCommunication!
}

type DeleteUserCommunicationSubscriptionPayload {
  userCommunication: UserCommunication!
}

input CreateUserCommunicationInput {
  mutedUserId: ID!
}

input DeleteUserCommunicationInput {
  userCommunicationId: ID!
}

enum UserCommunicationOrderBy {
  ID
  ID_DESC
}

type UserGiveaway implements Node {
  id: ID!
  giveawayId: ID!
  giveaway: Giveaway!
  userId: ID!
  user: User!
  rewardAmount: Float!
  won: Boolean!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type UserGiveawayConnection {
  pageInfo: PageInfo!
  edges: [UserGiveawayEdge]
  total: Int
}

type UserGiveawayEdge {
  node: UserGiveaway
  cursor: String!
}

type CreateUserGiveawayPayload {
  userGiveaway: UserGiveaway
}

type UpdateUserGiveawayPayload {
  userGiveaway: UserGiveaway
}

enum UserGiveawayOrderBy {
  ID
  ID_DESC
}

type UserInviteCode implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User
  inviteCodeId: ID!
  inviteCode: InviteCode!
}

type UserItemMeta {
  userIsPvpBot: Boolean
}

type UserItem implements Node {
  id: ID!
  status: UserItemStatus!
  acquiredValue: Float!
  consumedValue: Float
  consumeValue: Float!
  currentValue: Float
  currency: String!
  userId: ID!
  itemVariantId: ID!
  orderId: ID!
  steamOfferId: ID
  consumedAt: SequelizeDate
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  requestedAt: SequelizeDate
  processingAt: SequelizeDate
  orderedAt: SequelizeDate
  comment: String
  processor: User
  user: User
  itemVariant: ItemVariant!
  steamOffer: SteamOffer
  order: Order
  zincOrder: ZincOrder
  shipTo: ShipTo
  meta: UserItemMeta
}

type UserItemConnection {
  pageInfo: PageInfo!
  edges: [UserItemEdge]
  total: Int
}

type UserItemEdge {
  node: UserItem
  cursor: String!
}

type CheckUserItemStatusPayload {
  userItem: UserItem!
  userItems: [UserItem!]!
}

type UpdateUserItemPayload {
  userItem: UserItem!
}

type CreateUserItemSubscriptionPayload {
  source: UserItemSource
  userItem: UserItem!
}

type UpdateUserItemSubscriptionPayload {
  userItem: UserItem!
}

type DeleteUserItemSubscriptionPayload {
  userItem: UserItem!
}

input CheckUserItemStatusInput {
  userItemId: [ID!]!
  secret: String!
}

input UpdateUserItemInput {
  userItemId: ID!
  status: UserItemStatus!
  comment: String
}

input UpdateUserItemShipToInput {
  shipTo: ShipToInput!
  userItemId: ID!
}

input ShipToInput {
  address1: String!
  address2: String
  city: String!
  country: String!
  lastName: String!
  name: String!
  phone: String!
  postcode: String!
  region: String
}

enum UserItemOrderBy {
  ID
  ID_DESC
  CONSUMED_AT
  CONSUMED_AT_DESC
  CONSUMED_VALUE
  CONSUMED_VALUE_DESC
  CREATED_AT
  CREATED_AT_DESC
  UPDATED_AT
  UPDATED_AT_DESC
  VALUE
  VALUE_DESC
}

enum UserItemStatus {
  CONSUMED
  EXCHANGED
  AVAILABLE
  REQUESTED
  PROCESSING
  ORDERED
  RECEIVED
  LOCKED
}

enum UserItemSource {
  BOX_OPENING
  CRASH_WIN
  DICE_BET
  JACKPOT
  MATCH_BETTING_WIN
  PROMO_CODE
  PVP_BOX_OPENING
  PVP_WIN
}

type UserPreferences implements Node {
  id: ID!
  name: String
  lastName: String
  address1: String
  address2: String
  postcode: String
  region: String
  city: String
  country: Country
  birthDate: SequelizeDate
  gender: Gender
  phone: String
  userId: ID!
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  hideSteamProfile: Boolean
  hideProfileStats: Boolean
}

type UpdateUserPreferencesPayload {
  userPreferences: UserPreferences
}

input UpdateUserPreferencesInput {
  userId: ID!
  name: String
  lastName: String
  address1: String
  address2: String
  postcode: String
  region: String
  city: String
  country: String
  gender: Gender
  birthDate: SequelizeDate
  phone: String
  hideSteamProfile: Boolean
  hideProfileStats: Boolean
}

enum Gender {
  MALE
  FEMALE
}

type UserProgressChange implements Node {
  createdAt: SequelizeDate!
  externalId: ID!
  id: ID!
  source: UserProgressSource!
  updatedAt: SequelizeDate!
  user: User!
  userId: ID!
  valueAfter: Int!
  valueChange: Int!
}

type UserProgressChangeConnection {
  edges: [UserProgressChangeEdge]
  pageInfo: PageInfo!
  total: Int
}

type UserProgressChangeEdge {
  cursor: String!
  index: Int
  node: UserProgressChange
}

type UserProgressChangesSummaryConnection {
  edges: [UserProgressChangesSummaryEdge]
  pageInfo: PageInfo!
  total: Int
}

type UserProgressChangesSummaryEdge {
  cursor: String!
  node: UserProgressChangesSummary
}

type UserProgressChangesSummary {
  deposits: Float!
  games: Float!
  misc: Float!
  userId: ID!
}

enum UserProgressSource {
  ACHIEVEMENT_CLAIM
  BOX_PURCHASE
  CRASH_BET
  DICE_BET
  GAME_BET
  ITEM_SELL
  MATCH_BETTING_SLIP_BET
  PVP_BET
  PVP_BOX_GAME_BET
  XP_PURCHASE
}

enum UserProgressChangeOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum UserProgressChangeSummaryOrderBy {
  DEPOSITS
  DEPOSITS_DESC
  GAMES
  GAMES_DESC
  MISC
  MISC_DESC
}

type UserProgress implements Node {
  id: ID!
  createdAt: SequelizeDate!
  changes(
    after: String
    before: String
    first: PaginationAmount
    last: PaginationAmount
    orderBy: [UserProgressChangeOrderBy]
  ): UserProgressChangeConnection
  updatedAt: SequelizeDate!
  userId: ID!
  user: User!
  xp: BigInt!
  xpMultiplier: Float!
  level: Int!
  requiredXp(level: Int): BigInt
  nextRequiredXp: BigInt
}

type UpdateUserProgressSubscriptionPayload {
  source: UserProgressSource
  userProgress: UserProgress!
}

type PurchaseXpPayload {
  xpAmount: Int!
  cost: Float!
  currency: String!
  userProgress: UserProgress!
  userProgressChanges: [UserProgressChange!]!
}

input PurchaseXpInput {
  xpAmount: Int!
  currency: String
}

type UserPromoCodeMeta {
  balance: Float!
  currency: String!
}

type UserPromoCode {
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  meta: [UserPromoCodeMeta!]
  promoCodeId: ID!
  promoCode: PromoCode!
  userId: ID!
  user: User!
}

type UserPromoCodeConnection {
  pageInfo: PageInfo!
  edges: [UserPromoCodeEdge]
  total: Int
}

type UserPromoCodeEdge {
  node: UserPromoCode
  cursor: String!
}

enum UserPromoCodeOrderBy {
  CREATED_AT
  CREATED_AT_DESC
}

type UserRequirements {
  mustBeInTeam: Boolean
}

type UserStat implements Node {
  id: ID!
  userId: ID
  user: User
  marketId: ID!
  market: Market
  excluded: Boolean!
  stat: UserStatStat!
  type: UserStatType!
  dateFrom: SequelizeDate
  dateTo: SequelizeDate
  value: Float!
  currency: String!
  externalId: String
  externalModel: UserStatExternalModel
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type UserStatConnection {
  pageInfo: PageInfo!
  edges: [UserStatEdge]
  total: Int
}

type UserStatEdge {
  node: UserStat
  cursor: String!
}

type UserStatExternalModel {
  bet: Bet
  boxOpening: BoxOpening
  crashBet: CrashBet
  diceBet: DiceBet
}

enum UserStatOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  DATE_FROM
  DATE_FROM_DESC
  VALUE
  VALUE_DESC
}

enum UserStatStat {
  HIGHEST_BET
  HIGHEST_BET_LOSS
  HIGHEST_CRASH_MULTIPLIER
  HIGHEST_CRASH_WIN
  HIGHEST_ROULETTE_GREEN_WIN
  HIGHEST_ROULETTE_WIN
  HIGHEST_UNBOXING_WIN
  TOTAL_BOXES_OPENED
  TOTAL_COMMISSION
  TOTAL_COMMISSION_EARNT
  TOTAL_DEPOSITED
  TOTAL_PROFIT
  TOTAL_PROFIT_DAILY_FREE
  TOTAL_PROFIT_GAME_JACKPOT
  TOTAL_WAGERED
  TOTAL_WAGERED_CRASH
  TOTAL_WAGERED_DICE
  TOTAL_WAGERED_MATCH_BETTING
  TOTAL_WAGERED_PVP
  TOTAL_WAGERED_ROULETTE
  TOTAL_WAGERED_UNBOXING
  TOTAL_WITHDRAWN
}

enum UserStatType {
  ALL_TIME
  DAILY
  WEEKLY
}

type DailyWithdrawalRemainder {
  amount: Float!
  canRequest: Boolean!
  hasPendingRequest: Boolean!
  isRestricted: Boolean!
}

type UserMeta {
  isPvpBot: Boolean
}

type User implements Node {
  id: ID!
  mutedUntil: SequelizeDate
  marketingEmails: Boolean!
  openId: String
  steamId: String
  twitterId: String
  email: String
  verified: Boolean
  bannedUntil: SequelizeDate
  authentic: Boolean
  acceptTos: Boolean
  trader: Boolean!
  suspectedTrader: Boolean!
  dailyWithdrawLimit: Float
  lastDepositAt: SequelizeDate
  totalDeposit: Decimal
  totalWithdraw: Decimal
  totalCommissionEarnt: Decimal
  totalReferredDepositValue: Decimal
  currency: String!
  steamTradeUrl: String
  steamDisplayName: String
  avatar: String
  name: String
  displayName: String
  permissions: Int
  roles: [UserRole]
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  deletedAt: SequelizeDate
  lastActiveAt: SequelizeDate
  dailyConsecutiveActiveCount: Int!
  verificationStatus: VerificationStatus
  affiliatePromoCodes: [PromoCode!]!
  level: Int
  online: Boolean
  unlockedChat: Boolean
  marketId: ID
  market: Market
  affiliateUserId: ID
  affiliate: User
  affiliatedUsers(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [UserOrderBy]
  ): UserConnection!
  affiliateTierId: ID
  affiliateTier: AffiliateTier
  referralPromoCodeId: ID
  referralPromoCode: PromoCode
  stickyReferee: Boolean!
  teamId: ID
  team: Team
  customAffiliateId: String
  dailyWithdrawalRemainder: DailyWithdrawalRemainder
  totalUserItemValue(status: [UserItemStatus!]): Float
  preferences: UserPreferences
  messages(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): MessageConnection!
  orders(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [OrderOrderBy]
  ): OrderConnection!
  seeds(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): SeedConnection!
  transactions(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): TransactionConnection!
  tickets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    jackpotId: ID
  ): TicketConnection!
  achievements(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): AchievementConnection!
  wallets(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): [Wallet]
  documents(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
  ): DocumentConnection!
  walletChanges(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WalletChangeOrderBy]
  ): WalletChangeConnection!
  userItems(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    status: [UserItemStatus!]
  ): UserItemConnection!
  steamBot: SteamBot
  userProgress: UserProgress
  tradeBannedUntil: SequelizeDate
  totalUsersReferred: Int
  totalDepositorsReferred: Int
  customTitle: String
  customTitleColor: String
  totalDepositOfReferredUsers: Decimal
  totalWithdrawOfReferredUsers: Decimal
  steamApiKey: String
  withdrawalRestrictions: UserWithdrawalRestrictions
  notifications(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [NotificationOrderBy]
    unreadOnly: Boolean
  ): NotificationConnection!
  hideSteamProfile: Boolean
  microphoneEnabled: Boolean!
  meta: UserMeta
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
  total: Int
}

type UserEdge {
  node: User
  cursor: String!
  index: Int
}

type UpdateUserPayload {
  user: User
}

type UpdateUserEmailPayload {
  user: User
}

type RevertUserPayload {
  user: User
}

type AcceptTosPayload {
  acceptTos: Boolean!
}

type LoginPayload {
  user: User
}

type UpdateSuspectedTraderPayload {
  user: User
}

type SendValidationEmailPayload {
  success: Boolean!
}

type CreateUserSubscriptionPayload {
  user: User!
}

type UpdateUserSubscriptionPayload {
  user: User!
}

type AuthenticatedUserSubscriptionPayload {
  user: User!
}

input UpdateUserInput {
  authentic: Boolean
  bannedUntil: SequelizeDate
  customTitle: String
  customTitleColor: String
  dailyWithdrawLimit: Float
  displayName: String
  email: String
  marketId: ID
  marketingEmails: Boolean
  microphoneEnabled: Boolean
  mutedUntil: SequelizeDate
  permissions: Int
  roles: [UserRole]
  steamApiKey: String
  steamTradeUrl: String
  tradeBannedUntil: SequelizeDate
  trader: Boolean
  userId: ID!
  verificationStatus: VerificationStatus
  hideSteamProfile: Boolean
  teamId: ID
}

input UpdateUserEmailInput {
  email: String!
  redirectUri: String!
  userId: ID!
}

input RevertUserInput {
  userId: ID!
  dateTime: SequelizeDate!
}

input AcceptTosInput {
  acceptTos: Boolean!
}

input UpdateSuspectedTraderInput {
  userId: ID!
}

input SendValidationEmailInput {
  redirectUri: String!
  userId: ID!
}

enum UserOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  XP
  XP_DESC
  BALANCE
  BALANCE_DESC
  TOTAL_DEPOSIT
  TOTAL_DEPOSIT_DESC
  LAST_DEPOSIT_AT
  LAST_DEPOSIT_AT_DESC
  TOTAL_WITHDRAW
  TOTAL_WITHDRAW_DESC
  BOX_OPENINGS
  BOX_OPENINGS_DESC
  TICKETS
  TICKETS_DESC
  TOTAL_COMMISSION_EARNT
  TOTAL_COMMISSION_EARNT_DESC
}

enum UserPermission {
  USER
  MODERATOR
  SUPPORT
  ADMIN
}

enum UserRole {
  BOX_CREATOR
  BOX_EDITOR
  DEVELOPER
  MANAGER
  MODERATOR
  OWNER
  RISK_FRAUD
  STAFF
  SUPPORT
  SUPPORT_PLUS
  USER
}

enum VerificationStatus {
  UNDER_LIMIT
  REQUIRED
  VERIFIED
}

enum UserWithdrawalRestrictions {
  NO_RESTRICTIONS
  PENDING
  RESTRICTED
}

type VerifyEmailPayload {
  user: User
}

input VerifyEmailInput {
  hash: String!
  recaptcha: String!
  visualRecaptcha: String
}

input ResendVerificationEmailInput {
  userId: String!
  recaptcha: String!
  visualRecaptcha: String
}

type WalletChange implements Node {
  id: ID!
  type: WalletChangeType!
  externalId: ID
  valueChange: Decimal!
  valueAfter: Decimal!
  walletId: ID
  userId: ID
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  wallet: Wallet
  user: User
  externalItem: WalletChangeExternalItem!
}

type WalletChangeConnection {
  pageInfo: PageInfo!
  edges: [WalletChangeEdge]
  total: Int
}

type WalletChangeEdge {
  node: WalletChange
  cursor: String!
  index: Int
}

type WalletChangesSummaryConnection {
  pageInfo: PageInfo!
  edges: [WalletChangesSummaryEdge]
  total: Int
}

type WalletChangesSummaryEdge {
  node: WalletChangesSummary
  cursor: String!
}

type WalletChangesSummary {
  currency: String!
  deposits: Float!
  exchanges: Float!
  games: Float!
  misc: Float!
  userId: ID!
  withdraws: Float!
}

type WalletChangeExternalItem {
  box: Box
  boxOpening: BoxOpening
  diceBet: DiceBet
  exchange: Exchange
  promoCode: PromoCode
  trade: Trade
  transaction: Transaction
  userItem: UserItem
}

enum WalletChangeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum WalletChangeType {
  ACHIEVEMENT_CLAIM
  AFFILIATE_LOAN
  ALTERATION
  BOX_OPEN
  BOX_PURCHASE
  BOX_REFUND
  BOX_WIN
  COMMISSION
  COMMISSION_CLAIMED
  COMPENSATION
  CRASH_BET
  CRASH_REFUND
  CRASH_WIN
  CURRENCY_CONVERSION
  DICE_BET
  DICE_JACKPOT
  DICE_UPGRADE_BET
  DICE_UPGRADE_WIN
  DICE_WIN
  GAME_BET
  GAME_JACKPOT
  GAME_WIN
  GEMSTONE_GAME_WIN
  GIFT_CARD
  GIVEAWAY_WIN
  ITEM_EXCHANGE
  ITEM_WITHDRAW
  MATCH_BETTING_SLIP_BET
  MATCH_BETTING_SLIP_WIN
  PAYMENT
  PAYMENT_BONUS
  PAYMENT_WITHDRAWAL
  PROMO_CODE
  PVP_BET
  PVP_BOT_TOP_UP
  PVP_BOX_GAME_BET
  PVP_WIN
  TRADE_DEPOSIT
  TRADE_JOIN
  TRANSFER
  USER_IMPORT
  USER_ITEM_EXCHANGE_REVERT
  WAX_PEER_TRADE
  XP_PURCHASE
  ZBT_TRADE
}

enum WalletChangesSummaryOrderBy {
  DEPOSITS
  DEPOSITS_DESC
  EXCHANGES
  EXCHANGES_DESC
  GAMES
  GAMES_DESC
  MISC
  MISC_DESC
  WITHDRAWS
  WITHDRAWS_DESC
}

type Wallet implements Node {
  id: ID!
  name: WalletType
  amount: Float
  currency: String!
  userId: ID
  user: User
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  changes(
    after: String
    first: PaginationAmount
    before: String
    last: PaginationAmount
    orderBy: [WalletChangeOrderBy]
  ): WalletChangeConnection
}

type WalletConnection {
  pageInfo: PageInfo!
  edges: [WalletEdge]
  total: Int
}

type WalletEdge {
  node: Wallet
  cursor: String!
}

type UpdateWalletPayload {
  note: Note
  type: WalletChangeType @deprecated(reason: "Not used")
  wallet: Wallet @deprecated(reason: "Use wallets instead")
  wallets: [Wallet!]
}

type UpdateWalletSubscriptionPayload {
  wallet: Wallet!
  walletChange: WalletChange!
}

input UpdateWalletInput {
  walletId: ID!
  note: String!
  diff: Float!
  type: WalletChangeType
}

input AffiliateClaimAmountInput {
  amount: Float!
}

enum WalletOrderBy {
  ID
  ID_DESC
}

enum WalletType {
  AFFILIATE_EARNINGS
  BONUS
  GEMSTONE
  MAIN
}

type WaxPeerTrade implements Node {
  id: ID!
  itemVariantId: ID!
  itemVariant: ItemVariant
  userId: ID!
  user: User
  value: Float!
  valuePaid: Float
  currency: String!
  status: WaxPeerTradeStatus!
  partner: String
  token: String
  externalId: String
  externalStatus: WaxPeerTradeExternalStatus
  tradeOfferId: String
  externalMessage: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  expiresAt: SequelizeDate
  externalItemId: String
  float: String
  iconUrl: String
  isOfferSent: Boolean!
}

type WaxPeerTradeConnection {
  pageInfo: PageInfo!
  edges: [WaxPeerTradeEdge]
  total: Int
}

type WaxPeerTradeEdge {
  node: WaxPeerTrade
  cursor: String!
}

type WaxPeerItemConnection {
  pageInfo: PageInfo!
  edges: [WaxPeerItemEdge]
  total: Int
}

type WaxPeerItemEdge {
  node: WaxPeerItem
  cursor: String!
}

type CreateWaxPeerTradePayload {
  waxPeerTrade: WaxPeerTrade!
}

type TrackWaxPeerTradePayload {
  success: Boolean!
}

type CreateWaxPeerTradeSubscriptionPayload {
  waxPeerTrade: WaxPeerTrade!
}

type UpdateWaxPeerTradeSubscriptionPayload {
  waxPeerTrade: WaxPeerTrade!
}

type WaxPeerItem {
  float: String
  iconUrl: String
  id: ID!
  itemVariant: ItemVariant!
  value: Float!
}

input CreateWaxPeerTradeInput {
  itemVariantId: ID!
  recaptcha: String!
  value: Float!
  float: String
  iconUrl: String
  visualRecaptcha: String
  waxPeerItemId: ID
}

input TrackWaxPeerTradeInput {
  waxPeerTradeId: ID!
  secret: String
}

enum WaxPeerTradeOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
  VALUE
  VALUE_DESC
  UPDATED_AT
  UPDATED_AT_DESC
}

enum WaxPeerItemOrderBy {
  BEST_DEALS_ASC
  BEST_DEALS_DESC
  PRICE_ASC
  PRICE_DESC
}

enum WaxPeerTradeStatus {
  COMPLETED
  CREATED
  FAILED
  PROCESSING
}

enum WaxPeerTradeExternalStatus {
  COMPLETED
  DECLINED_AND_REFUNDED
  EXCEPTION
  PROCESSING
  SENT
  WAITING
  WAITING_FOR_SELLER_CONFIRMATION
}

type WithdrawalRequest implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  userId: ID!
  user: User
  processorId: ID
  processor: User
  amount: Float!
  approvedHistory: CreateWithdrawalHistory
  currency: String!
  status: WithdrawalRequestStatus!
}

type WithdrawalRequestConnection {
  pageInfo: PageInfo!
  edges: [WithdrawalRequestEdge]
  total: Int
}

type WithdrawalRequestEdge {
  node: WithdrawalRequest
  cursor: String!
}

type CreateWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type UpdateWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type IncreaseWithdrawalRequestPayload {
  withdrawalRequest: WithdrawalRequest!
}

type CreateWithdrawalRequestSubscriptionPayload {
  withdrawalRequest: WithdrawalRequest!
}

type UpdateWithdrawalRequestSubscriptionPayload {
  withdrawalRequest: WithdrawalRequest!
}

type CreateWithdrawalHistory {
  count: Int
  sum: Float
}

input CreateWithdrawalRequestInput {
  amount: Float!
}

input UpdateWithdrawalRequestInput {
  withdrawalRequestId: ID!
  amount: Float!
  status: WithdrawalRequestStatus!
}

input IncreaseWithdrawalRequestInput {
  amount: Float!
  globalId: String!
}

enum WithdrawalRequestOrderBy {
  ID
  ID_DESC
  CREATED_AT
  CREATED_AT_DESC
}

enum WithdrawalRequestStatus {
  APPROVED
  DENIED
  PENDING
}

type ZbtTrade implements Node {
  id: ID!
  itemVariantId: ID!
  itemVariant: ItemVariant
  userId: ID!
  user: User
  value: Float!
  valuePaid: Float
  currency: String!
  status: ZbtTradeStatus!
  steamAppName: SteamAppName!
  steamTradeUrl: String!
  isOfferSent: Boolean!
  externalId: String
  externalStatus: ZbtTradeExternalStatus
  externalItemId: String
  externalMessage: String
  float: String
  iconUrl: String
  tradeOfferId: String
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
}

type ZbtTradeConnection {
  pageInfo: PageInfo!
  edges: [ZbtTradeEdge]
  total: Int
}

type ZbtTradeEdge {
  node: ZbtTrade
  cursor: String!
}

type ZbtMarketplaceItemConnection {
  pageInfo: PageInfo!
  edges: [ZbtMarketplaceItemEdge]
  total: Int
}

type ZbtMarketplaceItemEdge {
  node: ZbtMarketplaceItem
  cursor: String!
}

type ZbtMarketplaceItem {
  float: String
  iconUrl: String
  id: ID!
  itemVariant: ItemVariant!
  quantity: Int!
  value: Float!
}

type CancelZbtTradePayload {
  success: Boolean!
}

type CreateZbtTradePayload {
  zbtTrade: ZbtTrade!
}

type TrackZbtTradePayload {
  success: Boolean!
}

type CreateZbtTradeSubscriptionPayload {
  zbtTrade: ZbtTrade!
}

type UpdateZbtTradeSubscriptionPayload {
  zbtTrade: ZbtTrade!
}

input CancelZbtTradeInput {
  zbtTradeId: ID!
}

input CreateZbtTradeInput {
  itemVariantId: ID!
  recaptcha: String!
  steamAppName: SteamAppName!
  value: Float!
  float: String
  iconUrl: String
  visualRecaptcha: String
}

input TrackZbtTradeInput {
  zbtTradeId: ID!
  secret: String
}

enum ZbtTradeOrderBy {
  ID
  ID_DESC
  VALUE
  VALUE_DESC
}

enum ZbtMarketplaceItemOrderBy {
  PRICE_ASC
  PRICE_DESC
}

enum ZbtTradeStatus {
  COMPLETED
  CREATED
  FAILED
  PROCESSING
}

enum ZbtTradeExternalStatus {
  CANCELLED
  COMPLETED
  RECEIVING
  WAITING_FOR_DELIVERY
  WAITING_FOR_PAYMENT
  WAITING_FOR_RECEIPT
}

type ZincOrder implements Node {
  id: ID!
  createdAt: SequelizeDate!
  updatedAt: SequelizeDate!
  requestId: String!
  merchantOrders: [ZincMerchantOrder!]!
  status: ZincOrderStatus!
  creatorId: ID!
  creator: User
  orderId: ID!
  order: Order!
  retailer: Retailer!
  giftMessage: String!
  maxOrderCost: Float!
  maxShippingCost: Float!
  maxShippingDays: Float!
  shippingPriority: ShippingPriority!
}

type ZincOrderConnection {
  pageInfo: PageInfo!
  edges: [ZincOrderEdge]
  total: Int
}

type ZincOrderEdge {
  node: ZincOrder
  cursor: String!
}

type CreateZincOrderPayload {
  zincOrder: ZincOrder
}

type AbortZincOrderPayload {
  zincOrder: ZincOrder
}

type CancelZincOrderPayload {
  zincOrder: ZincOrder
}

type RetryZincOrderPayload {
  zincOrder: ZincOrder
}

type CreateZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type UpdateZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type DeleteZincOrderSubscriptionPayload {
  zincOrder: ZincOrder!
}

type ZincMerchantOrder {
  merchantOrderId: String
  merchant: String
  account: String
  placedAt: SequelizeDate
  tracking: [String]
  productIds: [String]
  trackingUrl: String
  deliveryDate: String
  cancelledAt: SequelizeDate
}

type ZincProductSearchItem {
  productId: String
  title: String
  image: String
  reviewCount: Int
  rating: Float
  fresh: Boolean
  price: Float
}

type ZincProductSearchPayload {
  products: [ZincProductSearchItem!]!
}

input CreateZincOrderInput {
  giftMessage: String!
  maxOrderCost: Float!
  maxShippingCost: Float!
  maxShippingDays: Float!
  shippingPriority: ShippingPriority!
  userItemIds: [ID!]!
  discount: Int
}

input AbortZincOrderInput {
  zincOrderId: ID!
}

input CancelZincOrderInput {
  zincOrderId: ID!
}

input RetryZincOrderInput {
  zincOrderId: ID!
}

input ZincProductSearchInput {
  query: String!
  retailer: Retailer!
  page: Int!
}

enum ZincOrderOrderBy {
  CREATED_AT
  CREATED_AT_DESC
  ID
  ID_DESC
}

enum ZincOrderStatus {
  ABORTED
  ABORTING
  CANCELLED
  CANCELLING
  CREATED
  FAILED
  ORDERED
  ORDERING
}

enum Retailer {
  ALIEXPRESS
  AMAZON_CA
  AMAZON_DE
  AMAZON_MX
  AMAZON_UK
  AMAZON_US
  CLOUTJUICE_MERCH
  COSTCO
  FARFETCH
  HOMEDEPOT
  LOWES
  REDBUBBLE
  STOCKX
  WALMART
}

enum ProductCondition {
  NEW
  REFURBISHED
  UNACCEPTABLE
  USED_ACCEPTABLE
  USED_GOOD
  USED_LIKE_NEW
  USED_VERY_GOOD
}

enum ShippingPriority {
  CHEAPEST
  FASTEST
}
